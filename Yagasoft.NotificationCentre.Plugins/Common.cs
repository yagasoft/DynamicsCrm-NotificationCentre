// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// Author: Ahmed Elsawalhy (Yagasoft.com)
// Version: 3.8.4
// <auto-generated />

#region Imports

using System;
using System.Activities;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Metadata;
using Microsoft.Xrm.Sdk.Metadata.Query;
using Microsoft.Xrm.Sdk.Query;
using Microsoft.Xrm.Sdk.Workflow;
using Match = System.Text.RegularExpressions.Match;
using RelationshipType = Microsoft.Xrm.Sdk.Metadata.RelationshipType;

#endregion

namespace Yagasoft.Libraries.Common
{

	#region Enums

	/// <summary>
	///     The log levels
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum LogLevel
	{
		None = 0,
		Error = 10,
		Warning = 20,
		Info = 30,
		Debug = 40
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum LogMode
	{
		Crm = 10,
		File = 20,
		Both = 30
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum SplitMode
	{
		Size = 10,
		Date = 20,
		Both = 30
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum SplitFrequency
	{
		Hourly = 10,
		Daily = 20,
		Monthly = 30,
		Yearly = 40
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum PluginUser
	{
		ContextUser,
		InitiatingUser,
		System,
		Custom
	}

	#endregion

	#region Extensions

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class Extensions
	{
		private const string StringExceptionMsg = "String value cannot be empty.";
		private const string DefaultStringFormatExceptionMsg = "String format is invalid.";
		private const string DefaultNullExceptionMessage = "Value cannot be null.";
		private const string DefaultRangeMessage = "Parameter value out of range.";
		private const string DefaultArrayMemberMessage = "Array member can't be null.";
		private const string DefaultParameterName = "Unknown";
		private const string RegexEscapes = @"[\a\b\f\n\r\t\v\\""]";

		/// <summary>
		/// Return the distinct values of the source collection using the key returned by a selector function.<br />
		/// Credit: https://stackoverflow.com/a/24823445/1919456<br />
		/// </summary>
		public static IEnumerable<TSource> DistinctBy<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			var set = new HashSet<TResult>();

			foreach (var item in source)
			{
				var selectedValue = selector(item);

				if (set.Add(selectedValue))
				{
					yield return item;
				}
			}
		}

		#region Dates

		public static DateTime ConvertToCrmUserTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		public static DateTime ConvertToCrmUtcTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(-bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Utc);
		}

		public static DateTime ConvertBetweenCrmUsersTimeZone(this DateTime dateTime, IOrganizationService service,
			Guid user1Id, Guid user2Id)
		{
			var biases = CrmHelpers.GetUsersTimeZoneBiasMinutes(service, user1Id, user2Id);
			var bias1 = biases[user1Id];
			var bias2 = biases[user2Id];

			var biasedDate = dateTime.AddMinutes(-bias1).AddMinutes(bias2);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		#endregion

		// Credit: http://www.codeproject.com/Articles/290695/Extension-methods-to-simplify-null-argument-check

		#region Param checks

		#region NULL CHECK FOR OBJECT OF ANY CLASS

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : class
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF ANY CLASS

		#region NULL CHECK FOR OBJECT OF NULLABLE TYPE

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if type value is null.
		///     The method is constrained to objects of Nullable struct type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <typeparam name="T">Type of target object</typeparam>
		/// <param name="obj">Target object of type T.</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">Exception message.If not provoided default value is "Value can not be null."</param>
		public static void Require<T>(this T? obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF NULLABLE TYPE

		#region NULL CHECK FOR OBJECT ARRAY

		/// <summary>
		///     Method throws ArgumentNullException if any of object reference in array is null.
		///     Note : Using value types in array may result in unnecessary boxing.
		///     Use only when you do not care about message , parameter name and empty/whitespace string.
		///     Certainly not enough for production quality code.
		/// </summary>
		/// <param name="value">Object array containing target object references.</param>
		/// <param name="paramName"></param>
		/// <param name="message"></param>
		public static void Require(this object[] value, string paramName = DefaultParameterName,
			string message = DefaultArrayMemberMessage)
		{
			if (value == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (value.Any(param => param == null))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireCountBelow<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count >= max)
			{
				message = $@"Collection count must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAtMost<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max)
			{
				message = string.Format(@"Collection count must be less than or equal to ""{0}"".", max);
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAbove<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count <= min)
			{
				message = $@"Collection count must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAtLeast<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count < min)
			{
				message = $@"Collection count must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountInRange<T>(this T collection, int min, int max,
			string paramName = DefaultParameterName, string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max && collection.Count < min)
			{
				message = $@"Collection count must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		#endregion NULL CHECK FOR OBJECT ARRAY

		#region Null, format, and empty check for strings

		/// <summary>
		///     Extension method that throws ArgumentNullException if target string is null , empty or whitespace.
		///     The method is constrained to objects of string type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <param name="value">Target string object</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">
		///     Exception message.If not provided default value is "String value can not be null , empty of white
		///     space."
		/// </param>
		public static void Require(this string value, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
		{
			if (value == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireNotEmpty(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.Require(paramName);

			if (string.IsNullOrWhiteSpace(value))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireFormat(this string value, string regex, string paramName = DefaultParameterName,
			string message = DefaultStringFormatExceptionMsg)
		{
			value.Require(paramName);

			if (Regex.IsMatch(value, regex))
			{
				ThrowArgumentFormatException(ref message, ref paramName, ref regex);
			}
		}

		#endregion

		// Author: Ahmed Elsawalhy

		#region Range check for comparables

		public static void RequireBelow<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) >= 0)
			{
				message = $@"Parameter must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAtMost<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be less than or equal to ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAbove<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) <= 0)
			{
				message = $@"Parameter must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAtLeast<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0)
			{
				message = $@"Parameter must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireInRange<T>(this T number, T min, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0 || number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		#endregion

		#endregion

		#region Strings

		/// <summary>
		///     Credit: http://stackoverflow.com/a/6724896/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string Truncate(this string value, int maxChars, string replacement)
		{
			return value.Length <= maxChars ? value : value.Substring(0, maxChars) + replacement;
		}

		public static string ToTitleCase(this string str)
		{
			return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(str.ToLower());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsEmpty(this string str)
		{
			return string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsNotEmpty(this string str)
		{
			return !string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string StringLiteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					["\a"] = @"\a",
					["\b"] = @"\b",
					["\f"] = @"\f",
					["\n"] = @"\n",
					["\r"] = @"\r",
					["\t"] = @"\t",
					["\v"] = @"\v",
					["\0"] = @"\0",
					["\""] = @"\""",
					["\\"] = @"\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string StringUnliteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					[@"\a"] = "\a",
					[@"\b"] = "\b",
					[@"\f"] = "\f",
					[@"\n"] = "\n",
					[@"\r"] = "\r",
					[@"\t"] = "\t",
					[@"\v"] = "\v",
					[@"\0"] = "\0",
					[@"\"""] = "\"",
					[@"\\"] = "\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Compresses a string and returns a deflate compressed, Base64 encoded string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="uncompressedValue">String to compress</param>
		public static string Compress(this string uncompressedValue)
		{
			using (var compressedStream = new MemoryStream())
			{
				using (var uncompressedStream = new MemoryStream(Encoding.UTF8.GetBytes(uncompressedValue)))
				{
					using (var compressorStream = new DeflateStream(compressedStream, CompressionLevel.Optimal, true))
					{
						uncompressedStream.CopyTo(compressorStream);
					}
				}

				return Convert.ToBase64String(compressedStream.ToArray());
			}
		}

		/// <summary>
		///     Decompresses a deflate compressed, Base64 encoded string and returns an uncompressed string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="compressedValue">String to decompress.</param>
		public static string Decompress(this string compressedValue)
		{
			using (var decompressedStream = new MemoryStream())
			{
				using (var compressedStream = new MemoryStream(Convert.FromBase64String(compressedValue)))
				{
					using (var decompressorStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
					{
						decompressorStream.CopyTo(decompressedStream);
						return Encoding.UTF8.GetString(decompressedStream.ToArray());
					}
				}
			}
		}

		public static string CharLiteral(this char c)
		{
			return c == '\'' ? @"'\''" : string.Format("'{0}'", c);
		}

		#endregion

		#region METHOD THAT ACTUALLY THROWS EXCEPTION

		private static void ThrowArgumentNullException(ref string paramName, ref string message)
		{
			throw new ArgumentNullException(paramName, message);
		}

		private static void ThrowArgumentOutOfRangeException(ref string paramName, object number, ref string message,
			int currentCount = -1)
		{
			throw new ArgumentOutOfRangeException(paramName, number,
				message + ((currentCount >= 0) ? " Current size is " + currentCount : string.Empty));
		}

		private static void ThrowArgumentFormatException(ref string paramName, ref string message, ref string regex)
		{
			throw new ArgumentException(message + " Format: " + regex, paramName);
		}

		#endregion METHOD THAT ACTUALLY THROWS EXCEPTION
	}

	#endregion

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	// Copyright (c) 2016 Bas van de Sande - JourneyIntoCRM - http://journeyintocrm.com
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
	// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class EntitySerializer
	{
		public static string SerializeObject(Entity entity)
		{
			var ds = new DataSet("XmlData");
			var dt = new DataTable(entity.LogicalName);
			ConvertEntityToDataTable(dt, entity);
			ds.Tables.Add(dt);

			return ds.GetXml();
		}

		public static Entity DeserializeObject(string xml)
		{
			var dataSet = new DataSet();

			var xmlBytes = Encoding.UTF8.GetBytes(xml);

			using (var ms = new MemoryStream(xmlBytes))
			{
				dataSet.ReadXml(ms);
			}

			if (dataSet.Tables.Count <= 0)
			{
				return null;
			}

			var dt = dataSet.Tables[0];

			if (dt.Rows.Count <= 0)
			{
				return null;
			}

			var entity = new Entity(dt.TableName);
			var row = dt.Rows[0];

			foreach (DataColumn column in dt.Columns)
			{
				if (column.ColumnName == "Id")
				{
					entity.Id = (Guid?)SetAttributeValue(row[column.ColumnName]) ?? Guid.Empty;
				}
				else
				{
					entity[column.ColumnName] = SetAttributeValue(row[column.ColumnName]);
				}
			}

			return entity;
		}

		private static void ConvertEntityToDataTable(DataTable dataTable, Entity entity)
		{
			var row = dataTable.NewRow();
			dataTable.Columns.Add("Id");
			row["Id"] = GetAttributeValue(entity.Id);

			foreach (var attribute in entity.Attributes.Where(a => a.Value != null))
			{
				if (!dataTable.Columns.Contains(attribute.Key))
				{
					dataTable.Columns.Add(attribute.Key);
				}

				row[attribute.Key] = GetAttributeValue(attribute.Value);
			}

			foreach (var fv in entity.FormattedValues)
			{
				if (!dataTable.Columns.Contains(fv.Key + "name"))
				{
					dataTable.Columns.Add(fv.Key + "name");
				}

				row[fv.Key + "name"] = fv.Value;
			}

			dataTable.Rows.Add(row);
		}

		private static string GetAttributeValue(object entityValue)
		{
			string objectValue;
			var objectReference = "";
			var objectType = entityValue.GetType().FullName;

			if (entityValue is EntityReference)
			{
				objectValue = ((EntityReference)entityValue).Id.ToString();
				objectReference = ((EntityReference)entityValue).LogicalName;
			}
			else if (entityValue is OptionSetValue)
			{
				objectValue = ((OptionSetValue)entityValue).Value.ToString();
			}
			else if (entityValue is Money)
			{
				objectValue = Convert.ToString(((Money)entityValue).Value, CultureInfo.InvariantCulture.NumberFormat);
			}
			else if (entityValue is AliasedValue)
			{
				var av = (AliasedValue)entityValue;
				objectValue = GetAttributeValue(av.Value);
				objectReference = $"{av.EntityLogicalName},{av.AttributeLogicalName}";
			}
			else if (entityValue is Guid)
			{
				objectValue = entityValue.ToString();
			}
			else
			{
				if (entityValue.IsNumeric())
				{
					objectValue = Convert.ToString(entityValue, CultureInfo.InvariantCulture.NumberFormat);
				}
				else if (entityValue.IsDateTime())
				{
					objectValue = ((DateTime)entityValue).ToUniversalTime().ToString("u");
				}
				else
				{
					objectValue = entityValue.ToString();
				}
			}

			if (!string.IsNullOrWhiteSpace(objectReference))
			{
				objectReference += ",";
			}

			return $"{objectType}|{objectReference}{objectValue}";
		}

		private static object SetAttributeValue(object val)
		{
			if (val == null)
			{
				return null;
			}

			var input = val.ToString();
			var tokens = input.Split('|');

			if (tokens.Length != 2)
			{
				return null;
			}

			if (tokens[0].Equals(typeof(EntityReference).FullName))
			{
				var er = tokens[1].Split(',');
				if (er.Length == 2)
				{
					return new EntityReference(er[0], new Guid(er[1]));
				}
			}
			else if (tokens[0].Equals(typeof(OptionSetValue).FullName))
			{
				int i;
				int.TryParse(tokens[1], out i);
				if (i != int.MinValue)
				{
					return new OptionSetValue(i);
				}
			}
			else if (tokens[0].Equals(typeof(Money).FullName))
			{
				decimal d;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out d);
				if (d != decimal.MinValue)
				{
					return new Money(d);
				}
			}
			else if (tokens[0].Equals(typeof(AliasedValue).FullName))
			{
				var av = tokens[1].Split(',');
				if (av.Length == 3)
				{
					return new AliasedValue(av[0], av[1], SetAttributeValue(av[2]));
				}
			}
			else if (tokens[0].Equals(typeof(Guid).FullName))
			{
				Guid g;
				Guid.TryParse(tokens[1], out g);
				if (g != Guid.Empty)
				{
					return g;
				}
			}
			else if (tokens[0].Equals(typeof(DateTime).FullName))
			{
				DateTime dt;
				DateTime.TryParse(tokens[1], out dt);
				if (dt != DateTime.MinValue)
				{
					return dt.ToUniversalTime();
				}
			}
			else if (tokens[0].Equals(typeof(int).FullName))
			{
				int i32;
				int.TryParse(tokens[1], out i32);
				if (i32 != int.MinValue)
				{
					return i32;
				}
			}
			else if (tokens[0].Equals(typeof(bool).FullName))
			{
				return (tokens[1].ToUpper() == "TRUE");
			}
			else if (tokens[0].Equals(typeof(decimal).FullName))
			{
				decimal sd;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out sd);
				if (sd != decimal.MinValue)
				{
					return sd;
				}
			}
			else
			{
				// all other values
				return tokens[1];
			}

			return null;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class ExtensionMethods
	{
		public static bool IsNumeric(this object obj)
		{
			switch (Type.GetTypeCode(obj.GetType()))
			{
				case TypeCode.Byte:
				case TypeCode.SByte:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Decimal:
				case TypeCode.Double:
				case TypeCode.Single:
					return true;
				default:
					return false;
			}
		}

		public static bool IsDateTime(this object obj)
		{
			return Type.GetTypeCode(obj.GetType()) == TypeCode.DateTime;
		}

		public static string StringAggregate<T>(this T collection, string separator = ",")
			where T : IEnumerable<string>
		{
			if (collection == null || !collection.Any())
			{
				return string.Empty;
			}

			return collection.Aggregate((e1, e2) => $"{e1}{separator}{e2}");
		}

	}

	#region Helpers

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class Helpers
	{
		private static readonly IDictionary<Type, Func<object, string>> StringRepresentationsMap =
			new ConcurrentDictionary<Type, Func<object, string>>();

		/// <summary>
		///     Gets the name of the assembly by going back frames in the stack trace.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first assembly in the stack that does not equal this one.
		/// </param>
		/// <param name="skipAssemblyName">[Optional] The name of the assembly to skip if frames are set to '-1'.</param>
		/// <returns>The name of the assembly</returns>
		public static string GetAssemblyName(int skipFrames = -1, string skipAssemblyName = null)
		{
			var currentAssembly = new StackFrame().GetMethod().ReflectedType?.AssemblyQualifiedName;
			skipAssemblyName = string.IsNullOrWhiteSpace(skipAssemblyName) ? currentAssembly : skipAssemblyName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipAssemblyName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					currentAssembly = method.ReflectedType?.AssemblyQualifiedName;

					if (currentAssembly?.Contains(skipAssemblyName) == true)
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				currentAssembly = new StackFrame(skipFrames + 1).GetMethod().ReflectedType?.AssemblyQualifiedName;
			}

			return currentAssembly;
		}

		/// <summary>
		///     Gets the name of the class by going back frames in the stack trace.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">[Optional] The name of the class to skip if frames are set to '-1'.</param>
		/// <returns>The name of the class</returns>
		public static string GetClassName(int skipFrames = -1, string skipClassName = null)
		{
			Type declaringType = null;
			var currentClass = new StackFrame().GetMethod().ReflectedType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					declaringType = method.ReflectedType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className.Contains(skipClassName))
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				declaringType = new StackFrame(skipFrames + 1).GetMethod().ReflectedType;
			}

			return declaringType == null ? string.Empty : declaringType.FullName;
		}

		/// <summary>
		///     Gets the stack trace of the current execution path.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">[Optional] The name of the class to skip if frame are set to '-1'.</param>
		/// <returns>The stack trace</returns>
		public static string GetStackTrace(int skipFrames = -1, string skipClassName = null)
		{
			var currentClass = new StackFrame().GetMethod().DeclaringType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					var declaringType = method.DeclaringType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className.Contains(skipClassName))
					{
						continue;
					}

					skipFrames = i - 1;
					break;
				}
			}
			else if (skipFrames < 0)
			{
				skipFrames = 0;
			}

			return new StackTrace(skipFrames + 1).ToString();
		}

		/// <summary>
		///     Add a function that returns a string representing the given type's values to the pool in memory.<br />
		///     This function will be searched for when 'GetStringRepresentation' is called.
		/// </summary>
		/// <param name="evaluator">
		///     A function that takes an object of the given type
		///     and returns a string representation of the values of that type.
		/// </param>
		public static void AddStringRepresentationFunction<T>(Func<T, string> evaluator)
		{
			evaluator.Require();
			StringRepresentationsMap[typeof(T)] = obj => obj is T ? evaluator((T)obj) : null;
		}

		/// <summary>
		///     Gets the function that returns a string representing the given type's values from the pool in memory.<br />
		/// </summary>
		public static Func<object, string> GetStringRepresentationFunction(Type objectType)
		{
			if (objectType == null)
			{
				return null;
			}

			Func<object, string> evaluator;
			StringRepresentationsMap.TryGetValue(objectType, out evaluator);
			return evaluator ?? GetStringRepresentationFunction(objectType.BaseType);
		}

		/// <summary>
		///     Returns a string representing the given object's value.<br />
		///     This can be used in place of 'ToString'.<br />
		///     Custom functions can be defined and added to the pool using 'AddTypeStringRepresentation'.
		/// </summary>
		public static string GetStringRepresentation(object value)
		{
			if (value == null)
			{
				return "null";
			}

			StringBuilder builder;

			if (value is ICollection)
			{
				var collection = (ICollection)value;
				var enumerator = collection.GetEnumerator();
				builder = new StringBuilder();

				var jumpSize = (int)Math.Ceiling(collection.Count / 5.0);
				var index = 0;
				var skipped = false;

				builder.Append("[");

				while (enumerator.MoveNext())
				{
					if (index % jumpSize == 0 || index == 0)
					{
						if (index > 0)
						{
							builder.Append(",");

							if (skipped)
							{
								builder.Append("..,");
							}
						}

						builder.Append($"{GetStringRepresentation(enumerator.Current)}");
					}
					else
					{
						skipped = true;
					}

					index++;
				}

				builder.Append("]");

				return builder.ToString();
			}

			if (value is EntityReference)
			{
				var reference = (EntityReference)value;
				builder = new StringBuilder();

				builder.Append($"{{Logical name = {reference.LogicalName}, Id = {reference.Id}");

				if (!string.IsNullOrWhiteSpace(reference.Name))
				{
					builder.Append($", Name = {reference.Name}");
				}

				builder.Append("}");

				return builder.ToString();
			}

			if (value is Entity)
			{
				var reference = (Entity)value;
				return $"{{Logical name = {reference.LogicalName}, Id = {reference.Id}}}";
			}

			if (value.ToString() != value.GetType().ToString())
			{
				return value.ToString();
			}

			var function = GetStringRepresentationFunction(value.GetType());
			return function == null ? value.ToString() : function(value);
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class CacheHelpers
	{
		/// <summary>
		/// Build an object containing parameters used by the caching methods. The org ID must be provided in order to 
		/// differentiate the cache of different organisations on the same machine.
		/// </summary>
		/// <param name="orgId">The CRM organisation ID.</param>
		/// <param name="service">CRM service.</param>
		public static CacheParams BuildCacheParams(string orgId, IOrganizationService service)
		{
			return
				new CacheParams
				{
					OrgId = orgId,
					CacheSuffix = $"{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}",
					CacheExpiryTarget = DateTime.Now.AddMinutes(CrmHelpers.GetGenericConfig(service, orgId)?
						.GetAttributeValue<int?>("ldv_configurationcacheduration") ?? 5)
				};
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="offset">
		///     [OPTIONAL] The time after which to remove the object from the cache.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, DateTimeOffset? offset = null, string cacheKeysuffix = null)
		{
			if (item == null)
			{
				return default(T);
			}

			ObjectCache cache = MemoryCache.Default;

			RemoveFromMemCache(key, cacheKeysuffix);

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			cache.Add(key, item, offset ?? ObjectCache.InfiniteAbsoluteExpiration);

			return item;
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="slidingExpiration">
		///     The duration after which to remove the object from cache, if it was not accessed for that duration.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, TimeSpan slidingExpiration, string cacheKeysuffix = null)
		{
			if (item == null)
			{
				return default(T);
			}

			ObjectCache cache = MemoryCache.Default;

			RemoveFromMemCache(key, cacheKeysuffix);

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			cache.Add(key, item, new CacheItemPolicy { SlidingExpiration = slidingExpiration });

			return item;
		}

		/// <summary>
		///     Gets the object from the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		/// <param name="defaultValue">The value to return if the key can't be found in the cache.</param>
		public static TItemType GetFromMemCache<TItemType>(string key, string cacheKeysuffix = null,
			TItemType defaultValue = default(TItemType))
		{
			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (cache.Contains(key))
			{
				return (TItemType)cache.Get(key);
			}

			return defaultValue;
		}

		/// <summary>
		///     Removes the object from the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to remove.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static void RemoveFromMemCache(string key, string cacheKeysuffix = null)
		{
			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (cache.Contains(key))
			{
				cache.Remove(key);
			}
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="cacheParams">A string to append to all keys.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, CacheParams cacheParams,
			T defaultValue = default(T))
		{
			key.RequireNotEmpty(nameof(key));
			cacheFiller.Require(nameof(cacheFiller));
			cacheParams.Require(nameof(cacheParams));

			var cacheKey = $"{key}|{cacheParams.OrgId}";
			var cachedObject = GetFromMemCache<T>(cacheKey, cacheParams.CacheSuffix);

			if (Equals(defaultValue, cachedObject))
			{
				cachedObject = AddToMemCache(cacheKey, cacheFiller(),
					cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix);
			}

			return cachedObject;
		}
	}

	/// <summary>
	///     credit: http://blog.codeeffects.com/Article/Generate-Random-Numbers-And-Strings-C-Sharp <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class RandomGenerator
	{
		public enum SymbolFlag
		{
			Uppers = 0,
			Lowers = 1,
			Numbers = 2
		}

		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params string[] symbols)
		{
			var sb = new StringBuilder();

			var digits = symbols.Where(symbol => char.IsDigit(symbol[0])).ToArray();
			var letters = symbols.Where(symbol => char.IsLetter(symbol[0])).ToArray();

			var digitsCount = 0;
			var lettersCount = 0;
			var floatRatio = numberLetterRatio / 100.0;

			for (var i = 0; i < length; i++)
			{
				var filteredSymbols = symbols;

				if (isLetterStart && i == 0)
				{
					lettersCount++;
					filteredSymbols = letters;
				}
				else if (numberLetterRatio > -1)
				{
					if ((lettersCount / (float)length) >= (1 - floatRatio)
						|| (GetRandomNumber(0, 100) <= numberLetterRatio
							&& (digitsCount / (float)length) < floatRatio))
					{
						digitsCount++;
						filteredSymbols = digits;
					}
					else
					{
						lettersCount++;
						filteredSymbols = letters;
					}
				}

				sb.Append(filteredSymbols[GetRandomNumber(0, filteredSymbols.Length)]);
			}

			return sb.ToString();
		}

		public static string GetRandomString(int length, bool isLetterStart, params string[] symbols)
		{
			return GetRandomString(length, isLetterStart, -1, symbols);
		}

		public static string GetRandomString(int length, params string[] symbols)
		{
			return GetRandomString(length, false, -1, symbols);
		}

		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params SymbolFlag[] symbolFlags)
		{
			symbolFlags.Require(nameof(symbolFlags));

			var array = new List<string>();

			var arraySymbolUppers = new[]
									{
										"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U",
										"V", "W", "X", "Y",
										"Z"
									};

			var arraySymbolLowers = new[]
									{
										"a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u",
										"v", "w", "x", "y",
										"z"
									};

			var arrayNumbers = new[]
							   {
								   "0", "2", "3", "4", "5", "6", "8", "9"
							   };

			if (symbolFlags.Length <= 0)
			{
				symbolFlags = new[] { SymbolFlag.Uppers, SymbolFlag.Lowers, SymbolFlag.Numbers };
			}

			if (symbolFlags.Contains(SymbolFlag.Uppers))
			{
				array.AddRange(arraySymbolUppers);
			}

			if (symbolFlags.Contains(SymbolFlag.Lowers))
			{
				array.AddRange(arraySymbolLowers);
			}

			if (symbolFlags.Contains(SymbolFlag.Numbers))
			{
				array.AddRange(arrayNumbers);
			}

			return GetRandomString(length, isLetterStart, numberLetterRatio, array.ToArray());
		}

		public static string GetRandomString(int length, bool isLetterStart, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, isLetterStart, -1, symbolFlags);
		}

		public static string GetRandomString(int length, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, false, -1, symbolFlags);
		}

		public static int GetRandomNumber(int maxNumber = 100)
		{
			return GetRandomNumber(0, maxNumber);
		}

		public static int GetRandomNumber(int minNumber, int maxNumber)
		{
			using (var rngGenerator = new RNGCryptoServiceProvider())
			{
				var b = new byte[4];
				rngGenerator.GetBytes(b);
				var seed = (b[0] & 0x7f) << 24 | b[1] << 16 | b[2] << 8 | b[3];
				var r = new Random(seed);

				return r.Next(minNumber, maxNumber);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class DateTimeHelpers
	{
		/// <summary>
		///     Gets the number of seconds that has passed since 1/1/1970 12AM.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="endDate">[OPTIONAL=UtcNow] The date to count to.</param>
		/// <returns>Number of seconds.</returns>
		public static long GetSecondsSinceEpoch(DateTime? endDate = null)
		{
			return (long)(endDate ?? DateTime.UtcNow).Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, bool isLastOccurrence)
		{
			return GetDayOccurrenceOfMonth(dateOfMonth, dayOfWeek, 5, isLastOccurrence);
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, int occurrence,
			bool isLastOccurrence)
		{
			occurrence.RequireInRange(1, 5, "occurrence", "Occurrence must be greater than zero and less than 6.");

			if (isLastOccurrence)
			{
				occurrence = 5;
			}

			// Change to first day of the month
			var dayOfMonth = dateOfMonth.AddDays(1 - dateOfMonth.Day);

			// Find first dayOfWeek of this month;
			if (dayOfMonth.DayOfWeek > dayOfWeek)
			{
				dayOfMonth = dayOfMonth.AddDays(7 - (int)dayOfMonth.DayOfWeek + (int)dayOfWeek);
			}
			else
			{
				dayOfMonth = dayOfMonth.AddDays((int)dayOfWeek - (int)dayOfMonth.DayOfWeek);
			}

			// add 7 days per occurrence
			dayOfMonth = dayOfMonth.AddDays(7 * (occurrence - 1));

			// make sure this occurrence is within the original month
			if (dayOfMonth.Month == dateOfMonth.Month)
			{
				return dayOfMonth;
			}
			else
			{
				if (isLastOccurrence)
				{
					return dayOfMonth.AddDays(-7);
				}

				return null;
			}
		}
	}

	/// <summary>
	///     credit: http://pietschsoft.com/post/2008/02/net-35-json-serialization-using-the-datacontractjsonserializer <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class SerialiserHelpers
	{
		public static string SerialiseBase64(object value)
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
				{
					var serializer = new DataContractSerializer(value.GetType());
					serializer.WriteObject(writer, value);
					return Convert.ToBase64String(stream.ToArray());
				}
			}
		}

		public static T DeserialiseBase64<T>(string base64)
		{
			using (var stream = new MemoryStream(Convert.FromBase64String(base64)))
			{
				using (var reader = XmlDictionaryReader
					.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
				{
					var serializer = new DataContractSerializer(typeof(T));
					return (T)serializer.ReadObject(reader);
				}
			}
		}

		public static string SerialiseXml<T>(T obj)
		{
			using (var stream = new MemoryStream())
			{
				var serializer = new DataContractSerializer(obj.GetType());
				serializer.WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		public static T DeserializeXml<T>(string xml)
		{
			using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
			{
				var serializer = new DataContractSerializer(typeof(T));
				return (T)serializer.ReadObject(stream);
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static string SerializeObject<T>(T serializableObject)
		{
			using (var stream = new MemoryStream())
			{
				var serializer = new XmlSerializer(typeof(T));
				serializer.Serialize(stream, serializableObject);
				stream.Position = 0;
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static T DeserializeObject<T>(string xml)
		{
			using (var read = new StringReader(xml))
			{
				using (XmlReader reader = new XmlTextReader(read))
				{
					var serializer = new XmlSerializer(typeof(T));
					return (T)serializer.Deserialize(reader);
				}
			}
		}

		public static string SerialiseSimpleJson(IDictionary<string, string> dictionary, bool isUnformatted = false)
		{
			var pairs = dictionary.Select(pair =>
				string.Format((isUnformatted ? string.Empty : "\t") + "\"{0}\":\"{1}\"", pair.Key, pair.Value?.StringLiteral()))
				.ToArray();
			return "{" + (isUnformatted ? string.Empty : "\r\n") + (pairs.Any() ?
				pairs.Aggregate((e1, e2) => e1 + "," + (isUnformatted ? string.Empty : "\r\n") + e2) : string.Empty)
				+ (isUnformatted ? string.Empty : "\r\n") + "}";
		}

		public static IDictionary<string, string> DeserialiseSimpleJson(string json)
		{
			var matches = Regex.Matches(json,
				@"['""]?([^""'\s]*?)['""]?(?:\:\s*)(true|false|\d+|['""](?:\\""|\\'|[^'""])*?['""])");

			if (matches.Count <= 0)
			{
				throw new FormatException("JSON is empty or poorly formatted.");
			}

			var dictionary = new Dictionary<string, string>();

			foreach (Match match in matches)
			{
				var groups = match.Groups;

				// the whole string is a match and the rest are pairs
				if ((groups.Count - 1) % 2 != 0)
				{
					throw new FormatException("JSON is poorly formatted.");
				}

				if (string.IsNullOrEmpty(groups[2].Value))
				{
					continue;
				}

				dictionary.Add(groups[1].Value, groups[2].Value.Trim('\'', '\"').StringUnliteral());
			}

			return dictionary;
		}

		public static string SerialiseJson<T>(T serializableObject)
		{
			using (var memoryStream = new MemoryStream())
			{
				var serializer = new DataContractJsonSerializer(typeof(T));
				serializer.WriteObject(memoryStream, serializableObject);
				return Encoding.Default.GetString(memoryStream.ToArray());
			}
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class CrmHelpers
	{
		/// <summary>
		///     Retrieves the generic configuration record from CRM. All fields are returned.<br />
		///     If none is found, an empty entity record is returned.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="service">CRM Organisation Service</param>
		/// <param name="orgId">CRM Organisation ID to make caching unique</param>
		public static Entity GetGenericConfig(IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.CrmHelpers.GetGenericConfig|{orgId}";
			var configLocal = CacheHelpers.GetFromMemCache<Entity>(cacheKey);

			if (configLocal == null)
			{
				configLocal =
					(from configQ in new OrganizationServiceContext(service).CreateQuery("ldv_genericconfiguration")
					 where (int)configQ["statecode"] == 0
					 select configQ).FirstOrDefault();
				CacheHelpers.AddToMemCache(cacheKey, configLocal,
					DateTime.Now.AddMinutes(configLocal?.GetAttributeValue<int>("ldv_configurationcacheduration") ?? 5));
			}

			return configLocal
				?? new Entity("ldv_genericconfiguration")
				{
					["ldv_name"] = "Generic Config"
				};
		}

		internal static DateTime GetMetadataCacheExpiryDate(IOrganizationService service, string orgId)
		{
			return DateTime.Now.AddMinutes(GetGenericConfig(service, orgId)?
				.GetAttributeValue<int>("ldv_metadatacacheduration") ?? 12);
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetRecordName(IOrganizationService service, Entity record, string orgId)
		{
			return record.GetAttributeValue<string>(MetadataHelpers
				.GetEntityAttribute<string>(service, record.LogicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId));
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetRecordName(IOrganizationService service, string logicalName, Guid id, string orgId,
			string primaryNameField = null)
		{
			var nameField = string.IsNullOrWhiteSpace(primaryNameField)
				? MetadataHelpers.GetEntityAttribute<string>(service, logicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute,
					orgId)
				: primaryNameField;
			return service.Retrieve(logicalName, id, new ColumnSet(nameField)).GetAttributeValue<string>(nameField);
		}

		public static bool IsRecordExists(IOrganizationService service, string logicalName, Guid id, bool isActivity = false)
		{
			var query = new QueryByAttribute(logicalName);
			query.AddAttributeValue(isActivity ? "activityid" : logicalName + "id", id);
			query.ColumnSet = new ColumnSet(false);
			return service.RetrieveMultiple(query).Entities.Any();
		}

		/// <summary>
		///     Get the total number of records returned by the given query using a modded binary search algorithm.<br />
		///     It is recommended that the query's column-set is set to 'false' for speed.<br />
		///     Please note that the 'PageInfo' object in the query will be overwritten.<br />
		///     This does NOT work with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetRecordsCount(IOrganizationService service, QueryExpression query, int countPerPage = 5000,
			string cookie = null, int lowerPageLimit = 1, int upperPageLimit = int.MaxValue)
		{
			var minPage = lowerPageLimit;
			var minPageCount = GetCountInPage(service, query, cookie, minPage, countPerPage);

			// first page is already partially filled or empty, so there are no records after for sure
			if (minPageCount >= 0 && minPageCount < countPerPage)
			{
				return minPageCount;
			}

			var maxPage = minPage;
			int maxPageCount;

			// get max page with partial fill or no records, after which there are surely no records
			// jump pages using an exponent of 2 because it's more likely that there are low number of pages than high
			while (true)
			{
				maxPage = maxPage * 2;
				maxPage = Math.Min(maxPage, upperPageLimit);
				maxPageCount = GetCountInPage(service, query, cookie, maxPage, countPerPage);

				// a filled page is considered a minimum, so set it to reduce search range
				if (maxPageCount == countPerPage)
				{
					minPage = maxPage;
					minPageCount = maxPageCount;
				}
				else
				{
					break;
				}
			}

			var isMaxNextToMin = (minPage + 1) == maxPage;
			var isMaxPageEmpty = maxPageCount == 0;
			var isMaxPagePartial = maxPageCount > 0 && maxPageCount < countPerPage;

			// max page is next to min full page, and is empty or partially filled, so we have reached the end
			if (isMaxPagePartial || (isMaxPageEmpty && isMaxNextToMin))
			{
				return ((maxPage - 1) * countPerPage) + maxPageCount;
			}

			int currentPage;
			int currentPageCount;

			while (true)
			{
				// get the current page in the middle point between min and max
				currentPage = (int)Math.Ceiling((maxPage + minPage) / 2d);

				// if current is not min or max, get its count
				if (currentPage != minPage && currentPage != maxPage)
				{
					currentPageCount = GetCountInPage(service, query, cookie, currentPage, countPerPage);
				}
				else
				{
					currentPageCount = currentPage == minPage ? minPageCount : maxPageCount;
				}

				var isCurrentNextToMin = (minPage + 1) == currentPage;
				var isCurrentNextToMax = (maxPage - 1) == currentPage;
				var isCurrentPageEmpty = currentPageCount == 0;
				var isCurrentPagePartial = currentPageCount > 0 && currentPageCount < countPerPage;
				var isCurrentPageFull = currentPageCount == countPerPage;

				// current page is next to min full page or max empty page
				// and is empty or partially filled, so we have reached the end
				if (isCurrentPagePartial
					|| (isCurrentPageEmpty && isCurrentNextToMin) || (isCurrentPageFull && isCurrentNextToMax))
				{
					break;
				}

				if (isCurrentPageEmpty)
				{
					maxPage = currentPage;
				}

				if (isCurrentPageFull)
				{
					minPage = currentPage;
				}
			}

			return ((currentPage - 1) * countPerPage) + currentPageCount;
		}

		public static int GetCountInPage(IOrganizationService service, QueryExpression query, string cookie = null,
			int page = 1, int countPerPage = 5000)
		{
			query.PageInfo = query.PageInfo ?? new PagingInfo();
			query.PageInfo.Count = countPerPage;
			query.PageInfo.PageNumber = page;
			query.PageInfo.PagingCookie = query.PageInfo.PagingCookie ?? cookie;
			query.ColumnSet = query.ColumnSet ?? new ColumnSet(false);
			var result = service.RetrieveMultiple(query);
			query.PageInfo.PagingCookie = result.PagingCookie ?? cookie;
			return result.Entities.Count;
		}

		/// <summary>
		///     Gets records from CRM using the query given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     The cookie is saved in the query itself during retrieval, so either save the cookie somewhere
		///     and reset it before passing it here, or simply reuse the query for next pages.<br />
		///     You should not skip pages with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<Entity> RetrieveRecords(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1)
		{
			query.PageInfo =
				new PagingInfo
				{
					PageNumber = page <= 0
						? (query.PageInfo == null || query.PageInfo.PageNumber <= 0
							? 1
							: query.PageInfo.PageNumber)
						: page,
					Count = limit <= 0
						? (query.PageInfo == null || query.PageInfo.Count <= 0
							? 5000
							: query.PageInfo.Count)
						: (limit > 5000 ? 5000 : limit)
				};

			limit = limit <= 0 ? int.MaxValue : limit;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < limit && page <= 0);

			return entities;
		}

		/// <summary>
		///     Gets records from CRM using the FetchXML given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     You should not skip pages with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<Entity> RetrieveRecords(IOrganizationService service, string fetchXml,
			int limit = -1, int page = -1)
		{
			var isAllPages = page <= 0;
			page = page <= 0 ? 1 : page;
			var loopLimit = limit <= 0 ? int.MaxValue : limit;
			var count = limit > 5000 ? 5000 : limit;
			string cookie = null;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				fetchXml = SetFetchPaging(fetchXml, page, count, cookie);

				// fetch the records
				records = service.RetrieveMultiple(new FetchExpression(fetchXml));

				// next time get the next bundle of records
				cookie = records.PagingCookie;
				page++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < loopLimit && isAllPages);

			return entities;
		}

		private static string SetFetchPaging(string fetchXml, int page, int count = -1, string cookie = null)
		{
			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var fetchNode = doc.SelectNodes("//fetch")?.Cast<XmlNode>().FirstOrDefault();

			if (fetchNode == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var tempDoc = fetchNode.OwnerDocument;

			if (tempDoc == null)
			{
				throw new FormatException("Couldn't find owner document in FetchXML node.");
			}

			if (fetchNode.Attributes == null)
			{
				throw new FormatException("Couldn't find attributes collection in FetchXML node.");
			}

			var attribute = tempDoc.CreateAttribute("page");
			attribute.Value = page.ToString();
			fetchNode.Attributes.SetNamedItem(attribute);

			if (count > 0)
			{
				attribute = tempDoc.CreateAttribute("count");
				attribute.Value = count.ToString();
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			if (!string.IsNullOrWhiteSpace(cookie))
			{
				attribute = tempDoc.CreateAttribute("paging-cookie");
				attribute.Value = cookie;
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			return doc.OuterXml;
		}

		/// <summary>
		///     Extracts the entity references from a record URL. Usually the URL is provided as input to a custom activity.<br />
		///     Execution Context can be null, it is used to cache inside a plugin only.<br />
		///     Author: Ahmed Elsawalhy<br />
		///     Credit: Yousra Mohamed
		/// </summary>
		public static List<EntityReference> GetEntityReferencesFromUrls(IOrganizationService service, string orgId,
			params string[] dynamicUrlParams)
		{
			// loop over dynamic urls to retrieve entity reference
			return (from url in dynamicUrlParams
					where url.Contains("etc=") && url.Contains("id=")
					select url.Trim().Split('?')
					into urlParts
					select urlParts[1].Split('&')
					into urlParams
					let objectTypeCode = urlParams.First(p => p.Contains("etc=")).Replace("etc=", "")
					let objectId = urlParams.First(p => p.Contains("id=")).Replace("id=", "")
					let entityName = MetadataHelpers.GetEntityNameUsingTypeCode(service, int.Parse(objectTypeCode), orgId)
					select new EntityReference(entityName, Guid.Parse(objectId))).ToList();
		}

		/// <summary>
		///     Executes given requests in bulk. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static Dictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(IOrganizationService service,
			List<OrganizationRequest> requests,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var bulkRequest =
				new ExecuteMultipleRequest
				{
					Requests = new OrganizationRequestCollection(),
					Settings =
						new ExecuteMultipleSettings
						{
							ContinueOnError = isContinueOnError,
							ReturnResponses = isReturnResponses
						}
				};

			var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

			var batchCount = Math.Ceiling(requests.Count / (double)batchSize);

			// take bulk size only for each iteration
			for (var i = 0; i < batchCount; i++)
			{
				// clear the previous batch
				bulkRequest.Requests.Clear();
				perBulkResponses.Clear();

				// take batches
				bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
				var bulkResponses = (ExecuteMultipleResponse)service.Execute(bulkRequest);

				// no need to build a response
				if (!isReturnResponses)
				{
					// break on error and no 'continue on error' option
					if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
					{
						break;
					}
					else
					{
						bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
						continue;
					}
				}

				for (var j = 0; j < bulkResponses.Responses.Count; j++)
				{
					var request = bulkRequest.Requests[j];
					var bulkResponse = bulkResponses.Responses[j];
					var fault = bulkResponse.Fault;
					string faultMessage = null;

					// build fault message
					if (fault != null)
					{
						var builder = new StringBuilder();
						builder.AppendFormat("Message: \"{0}\", code: {1}", fault.Message, fault.ErrorCode);

						if (fault.TraceText != null)
						{
							builder.AppendFormat(", trace: \"{0}\"", fault.TraceText);
						}

						if (fault.InnerFault != null)
						{
							builder.AppendFormat(", inner message: \"{0}\", inner code: {1}", fault.InnerFault.Message,
								fault.InnerFault.ErrorCode);

							if (fault.InnerFault.TraceText != null)
							{
								builder.AppendFormat(", trace: \"{0}\"", fault.InnerFault.TraceText);
							}
						}

						faultMessage = builder.ToString();
					}

					var response =
						new ExecuteBulkResponse
						{
							RequestType = request.GetType(),
							Response = bulkResponse.Response,
							ResponseType = bulkResponse.Response == null ? null : bulkResponse.Response.GetType(),
							Fault = fault,
							FaultMessage = faultMessage
						};
					responses[request] = response;
					perBulkResponses[request] = response;
				}

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);

				// break on error and no 'continue on error' option
				if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
				{
					break;
				}
			}

			return responses;
		}

		public static void RunWorkflow(IOrganizationService service, Guid entityId, Guid workflowId)
		{
			service.Execute(
				new ExecuteWorkflowRequest
				{
					EntityId = entityId,
					WorkflowId = workflowId
				});
		}

		/// <summary>
		///     Checks whether the given FetchXML returns any records.
		///  The record's ID is added to the FetchXML is as a condition.
		/// </summary>
		public static bool IsConditionMet(IOrganizationService service, string fetchXml,
			EntityReference record, string orgId)
		{
			service.Require("service");
			fetchXml.RequireNotEmpty("fetchXml");
			record.Require("record");

			var primaryIdName = MetadataHelpers.GetEntityAttributes(service, record.LogicalName, orgId,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute).PrimaryIdAttribute;
			var finalFetchXml = string.Empty;

			var querySplit = fetchXml.Split(new[] { "</entity>" }, StringSplitOptions.None);

			finalFetchXml += querySplit[0];
			finalFetchXml += "<filter type='and'> ";
			finalFetchXml += "<condition attribute='" + primaryIdName + "' operator='eq' value= '" + record.Id + "' /> ";
			finalFetchXml += "</filter>" + "</entity>";
			finalFetchXml += querySplit[querySplit.Length - 1];

			return service.RetrieveMultiple(new FetchExpression(finalFetchXml)).Entities.Any();
		}

		public static string BuildExceptionMessage(Exception ex, string preMessage = null)
		{
			return (preMessage == null ? string.Empty : preMessage + "\r\n") +
				"Exception: " + ex.GetType() +
				"\r\nMessage: " + ex.Message +
				(ex.Source == null ? string.Empty : "\r\nSource: " + ex.Source) +
				(ex.StackTrace == null
					? string.Empty
					: "\r\nStack trace:\r\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "CrmHelpers"))) +
				(ex.InnerException == null
					? string.Empty
					: "\r\nInner exception: " + ex.InnerException.GetType() +
						"\r\nInner message: " + ex.InnerException.Message +
						(ex.InnerException.Source == null ? string.Empty : "\r\nInner source: " + ex.InnerException.Source) +
						(ex.InnerException.StackTrace == null
							? string.Empty
							: "\r\nInner stack trace:\r\n" + ex.InnerException.StackTrace));
		}

		public static InvalidPluginExecutionException BuildInvalidPluginExecException(Exception ex, string preMessage = null)
		{
			preMessage = (preMessage == null ? string.Empty : preMessage + " ") +
				"<div style=\"display:none\">Exception: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				(ex.InnerException == null
					? string.Empty
					: " Inner exception: " + ex.InnerException.GetType() + " => \"" + ex.InnerException.Message + "\".") +
				"</div>";

			var message = "\nException: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				"\nSource: " + ex.Source +
				"\n\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "CrmHelpers")) + "\n" +
				(ex.InnerException == null
					? string.Empty
					: "\n\nInner exception: " + ex.InnerException.GetType() + " => \"" +
						ex.InnerException.Message + "\"." +
						"\nSource: " + ex.InnerException.Source +
						"\n\n" + ex.InnerException.StackTrace + "\n");

			message = message
				.Replace("\"", "&quot;").Replace("'", "\\'").Replace("\n", "<br />").Replace("\\n", "<br />").Replace("\r",
					string.Empty);

			var script = "<br />" +
				"<button class=\"ms-crm-RefreshDialog-Button\" style=\"margin-right: 30px; margin-left: 8px;\"" +
				"onclick=\"" +
				" var w = window.open('', 'Error Details', 'height=100, width=600, toolbar=no, menubar=no, resizable=no, scrollbars=yes, location=no, directories=no, status=no');"
				+
				" parent.$(w.document.body).html('" + message + "');" +
				" w.document.title = 'Error Details';" +
				" parent.$(w.document.body).css({ 'color': 'blue', 'font-size': 13 });" +
				"\">More Details</button>"
				+ "<br />"
				+ "<br />";

			return new InvalidPluginExecutionException(preMessage + script, ex);
		}

		public static void LogAttributeValues(AttributeCollection attributes, Entity labelsRecord, CrmLog log,
			string logLabel = null)
		{
			attributes.Require("attributes");
			labelsRecord.Require("labelsRecord");
			log.Require("log");

			var attributesInfo = new StringBuilder();
			attributesInfo.Append("Attribute values (" + attributes.Count + "):");

			foreach (var attribute in attributes.OrderBy(pair => pair.Key))
			{
				var value = attribute.Value;

				if (value is OptionSetValue)
				{
					value = labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: value;

					if (value is OptionSetValue)
					{
						value = ((OptionSetValue)value)?.Value;
					}
				}
				else if (value is EntityReference)
				{
					value = (labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: ((EntityReference)value).Name) ?? value;

					if (value is EntityReference && value != null)
					{
						value = labelsRecord.GetAttributeValue<EntityReference>(attribute.Key)?.Name;
					}
				}
				else if (value is Money)
				{
					value = attribute.Value;
				}

				attributesInfo.Append("\r\n    \"" + attribute.Key + "\" => \"" + value + "\".");
			}

			log.Log(new LogEntry(logLabel ?? "Entity Object Values", LogLevel.Debug,
				labelsRecord.Id.ToString(), labelsRecord.LogicalName, attributesInfo.ToString()));
		}

		#region Relations helpers

		public static List<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			MetadataHelpers.RelationType[] relationTypes, string orgId,
			FilterExpression filter = null, params string[] attributes)
		{
			var related = new List<Entity>();

			if (relationTypes == null || relationTypes.Length <= 0)
			{
				return related;
			}

			var relationAttributes =
				new[]
				{
					MetadataHelpers.RelationAttribute.SchemaName, MetadataHelpers.RelationAttribute.RelationshipType, MetadataHelpers.RelationAttribute.IntersectEntityName,
					MetadataHelpers.RelationAttribute.ReferencedEntity, MetadataHelpers.RelationAttribute.ReferencedAttribute,
					MetadataHelpers.RelationAttribute.ReferencingEntity, MetadataHelpers.RelationAttribute.ReferencingAttribute,
					MetadataHelpers.RelationAttribute.Entity1LogicalName, MetadataHelpers.RelationAttribute.Entity1IntersectAttribute,
					MetadataHelpers.RelationAttribute.Entity2LogicalName, MetadataHelpers.RelationAttribute.Entity2IntersectAttribute
				};

			var relations = MetadataHelpers
				.GetCustomRelationships(service, entity.LogicalName, relationTypes, relationAttributes, orgId)
				.Select(r => MetadataHelpers.BuildRelationMetadata(r,
					r.RelationshipType == RelationshipType.OneToManyRelationship
						? MetadataHelpers.RelationType.OneToManyRelationships
						: MetadataHelpers.RelationType.ManyToManyRelationships)).ToList();
			return GetRelatedRecordsInner(service, entity, relations, orgId, filter, attributes);
		}

		public static List<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			string relationName, string orgId, FilterExpression filter = null, params string[] attributes)
		{
			service.Require(nameof(service));
			entity.Require(nameof(entity));
			relationName.RequireNotEmpty(nameof(relationName));

			var relation = MetadataHelpers.GetRelation(service, entity.LogicalName, relationName, orgId);
			return GetRelatedRecordsInner(service, entity, new List<RelationMetadata> { relation }, orgId,
				filter, attributes);
		}

		private static List<Entity> GetRelatedRecordsInner(IOrganizationService service, EntityReference entity,
			List<RelationMetadata> relations, string orgId, FilterExpression filter = null, params string[] attributes)
		{
			var related = new List<Entity>();

			var idFieldName = MetadataHelpers.GetEntityAttribute<string>(service, entity.LogicalName,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

			var manyToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToManyRelationships);

			if (manyToMany.Any())
			{
				foreach (var rel in manyToMany)
				{
					var entity2Name = rel.Entity1Name == entity.LogicalName
						? rel.Entity2Name
						: rel.Entity1Name;
					var entity2Id = rel.Entity1Name == entity.LogicalName
						? rel.Entity2FieldName
						: rel.Entity1FieldName;
					var intersectEntity = rel.IntersectingEntityName;

					related.AddRange(GetRecords(entity, service, entity2Name, intersectEntity, entity2Id,
						entity2Id, idFieldName, -1, -1, filter, attributes));
				}
			}

			var oneToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.OneToManyRelationships);

			if (oneToMany.Any())
			{
				foreach (var rel in oneToMany)
				{
					var entity2Name = rel.Entity2Name;
					var entity2LookupName = rel.Entity2FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			var manyToOne = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToOneRelationships);

			if (manyToOne.Any())
			{
				foreach (var rel in manyToOne)
				{
					var entity2Name = rel.Entity1Name;
					var entity2LookupName = rel.Entity1FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			return related;
		}

		#endregion

		#region User helpers

		public static List<Guid> GetTeamMembers(IOrganizationService service, Guid teamId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return (from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("teammembership")
							on user["systemuserid"] equals member["systemuserid"]
						join teamQ in svcContext.CreateQuery("team")
							on member["teamid"] equals teamQ["teamid"]
						where teamQ["teamid"].Equals(teamId)
						select (Guid)user["systemuserid"]).ToList();
			}
		}

		public static List<Guid> GetQueueMembers(IOrganizationService service, Guid queueId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return (from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("queuemembership")
							on user["systemuserid"] equals member["systemuserid"]
						join queue in svcContext.CreateQuery("queue")
							on member["queueid"] equals queue["queueid"]
						where queue["queueid"].Equals(queueId)
						select (Guid)user["systemuserid"]).ToList();
			}
		}

		/// <summary>
		///     From the SDK: http://msdn.microsoft.com/en-us/library/hh670609.aspx <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetPreferredLangCode(IOrganizationService service, EntityReference record)
		{
			if (record.LogicalName == "systemuser")
			{
				var userSettingsQuery = new QueryExpression("usersettings");
				userSettingsQuery.ColumnSet.AddColumns("uilanguageid", "systemuserid");
				userSettingsQuery.Criteria.AddCondition("systemuserid", ConditionOperator.Equal, record.Id);
				var userSettings = service.RetrieveMultiple(userSettingsQuery);

				if (userSettings.Entities.Count > 0)
				{
					var code = (int)userSettings.Entities[0]["uilanguageid"];
					return code <= 0 ? 1033 : code;
				}
			}
			else if (record.LogicalName == "account" || record.LogicalName == "contact")
			{
				Entity result;

				try
				{
					result = service.Retrieve(record.LogicalName, record.Id, new ColumnSet("ldv_preferredcommunicationlanguage"));
				}
				catch
				{
					// field does not exist
					return 1033;
				}

				if (!result.Contains("ldv_preferredcommunicationlanguage"))
				{
					return 1033;
				}

				return ((OptionSetValue)result["ldv_preferredcommunicationlanguage"]).Value;
			}
			else
			{
				throw new NotSupportedException("Entity does not support a default language spec '" + record.LogicalName + "'.");
			}

			return 1033;
		}

		public static int GetUserTimeZoneBiasMinutes(IOrganizationService service, Guid userId)
		{
			return GetUsersTimeZoneBiasMinutes(service, userId).FirstOrDefault().Value;
		}

		public static IDictionary<Guid, int> GetUsersTimeZoneBiasMinutes(IOrganizationService service, params Guid[] userIds)
		{
			var query = new QueryExpression("usersettings");
			var filter = new FilterExpression(LogicalOperator.Or);

			foreach (var userId in userIds)
			{
				filter.AddCondition("systemuserid", ConditionOperator.Equal, userId);
			}

			query.ColumnSet = new ColumnSet("systemuserid", "timezonebias");
			query.Criteria.Filters.Add(filter);

			var userSettings = service.RetrieveMultiple(query).Entities;

			if (userSettings == null || userSettings.Count < userIds.Length
				|| userSettings.Any(settings => !settings.Contains("timezonebias")))
			{
				throw new Exception("Can't retrieve the settings of the users.");
			}

			return userSettings.ToDictionary(
				settings => settings.GetAttributeValue<Guid>("systemuserid"),
				settings => settings.GetAttributeValue<int>("timezonebias") * -1);
		}

		public static Guid? GetManagerId(IOrganizationService service, Guid userId)
		{
			var user = service.Retrieve("systemuser", userId, new ColumnSet("parentsystemuserid"));

			if (!user.Contains("parentsystemuserid"))
			{
				throw new Exception("User record does not contain a manager.");
			}

			return ((EntityReference)user["parentsystemuserid"]).Id;
		}

		/// <summary>
		///     Validates that the owner can edit the record.
		/// </summary>
		/// <param name="targetRecord">The target record to check for access rights.</param>
		/// <param name="targetOwner">The owner to check the rights for.</param>
		public static bool CanUpdateRecord(IOrganizationService service, EntityReference targetRecord,
			EntityReference targetOwner)
		{
			// request user's access rights to current record
			var principalAccessRequest =
				new RetrievePrincipalAccessRequest
				{
					Principal = targetOwner,
					Target = targetRecord
				};

			// response will contain AccessRights mask, like AccessRights.WriteAccess | AccessRights.ReadAccess | ...
			var principalAccessResponse = (RetrievePrincipalAccessResponse)service.Execute(principalAccessRequest);

			// if user can't edit record
			if ((principalAccessResponse.AccessRights & AccessRights.WriteAccess) != AccessRights.WriteAccess)
			{
				return false;
			}

			return true;
		}

		#endregion

		#region Placeholder parsers

		public static string ParseAttributeVariables(IOrganizationService service, string rawText,
			EntityReference recordRef, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			recordRef.Require(nameof(recordRef));
			orgId.RequireNotEmpty(nameof(orgId));

			var record = service.Retrieve(recordRef.LogicalName, recordRef.Id, new ColumnSet(true));
			return ParseAttributeVariables(service, rawText, record, userIdForTimeZone, orgId,
				cachedValues, placeholderLabel);
		}

		/// <summary>
		///     Replaces all placeholders with their values. Traverses lookups and evaluates conditions.
		/// </summary>
		/// <param name="record">
		///     The record whose values will be used to replace the placeholders.
		///     All attributes in This record should be fully loaded.
		/// </param>
		public static string ParseAttributeVariables(IOrganizationService service, string rawText,
			Entity record, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			orgId.RequireNotEmpty(nameof(orgId));

			if (string.IsNullOrEmpty(rawText))
			{
				return string.Empty;
			}

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var placeholderGuards = BuildPlaceholderGuards(record, placeholderLabel);

			var rawMatches = Regex.Matches(rawText,
				@"{(?:((?>(?<c1>{)|[^{}]+?|(?<-c1>}))+?(?(c1)(?!))\?\?(?>(?<c2>{)|[^{}]+?|(?<-c2>}))+(?(c2)(?!))::(?>(?<c3>{)|[^{}]+?|(?<-c3>}))+?(?(c3)(?!)))|((?>(?<c2>{)|[^{}]+?|(?<-c2>}))+(?(c2)(?!))))}");
			var matchesList = new List<Match>();

			foreach (Match match in rawMatches)
			{
				matchesList.Add(match);
			}

			// let's make sure that we only parse the outermost placeholders first
			var qualifiedMatches = matchesList.Where(m => matchesList.All(m2 =>
				((m.Index <= m2.Index && m.Index + m.Length <= m2.Index) || m.Index >= m2.Index + m2.Length)
					|| (m.Index <= m2.Index && m.Index + m.Length >= m2.Index + m2.Length)))
				.Select(m => m.Index).ToArray();

			var parsedVars = Regex.Replace(
				rawText,
				@"{" + placeholderGuards +
					@"(?:(?:((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))\?\?((?>(?<c2>{)|[^{}]+?|(?<-c2>}))*)(?(c2)(?!))::((?>(?<c3>{)|[^{}]+?|(?<-c3>}))*?)(?(c3)(?!)))|((?>(?<c2>{)|[^{}]+?|(?<-c2>}))+)(?(c2)(?!)))"
					+
					"}",
				match =>
				{
					if (!match.Success || !qualifiedMatches.Contains(match.Index))
					{
						return match.Value;
					}

					var predicate = match.Groups[1].Value;
					var trueValue = match.Groups[2].Value;
					var falseValue = match.Groups[3].Value;

					if (predicate.IsEmpty())
					{
						return ParseAttributeVariable(service, $"{{{match.Groups[4].Value}}}", record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
					}

					var predicateMatch = Regex.Match(predicate,
						@"^((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))(?:(==|[<>]=?|!=)((?>(?<c2>{)|[^{}]+|(?<-c2>}))*?)(?(c2)(?!)))?$");

					var conditionLeft = predicateMatch.Groups[1].Value;
					bool isTrue;
					var parsedConditionLeft = ParseAttributeVariables(service, conditionLeft, record,
						userIdForTimeZone, orgId, cachedValues, placeholderLabel);
					parsedConditionLeft = string.IsNullOrWhiteSpace(parsedConditionLeft) ? null : parsedConditionLeft;

					if (predicateMatch.Groups[2].Value.IsNotEmpty() && predicateMatch.Groups[3].Value.IsNotEmpty())
					{
						var comparator = predicateMatch.Groups[2].Value;
						var conditionRight = predicateMatch.Groups[3].Value;
						var parsedConditionRight = ParseAttributeVariables(service, conditionRight, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						parsedConditionRight = string.IsNullOrWhiteSpace(parsedConditionRight) ? null : parsedConditionRight;

						var comparison = CompareValues(parsedConditionLeft, parsedConditionRight);

						switch (comparator)
						{
							case "==":
								isTrue = comparison == 0;
								break;
							case "<":
								isTrue = comparison < 0;
								break;
							case "<=":
								isTrue = comparison <= 0;
								break;
							case ">":
								isTrue = comparison > 0;
								break;
							case ">=":
								isTrue = comparison >= 0;
								break;
							case "!=":
								isTrue = comparison != 0;
								break;
							default:
								throw new Exception($"'{predicateMatch.Value}' is in an invalid format.");
						}
					}
					else
					{
						isTrue = parsedConditionLeft != null;
					}

					return isTrue ? trueValue : falseValue;
				});

			return parsedVars == rawText
				? parsedVars
				: ParseAttributeVariables(service, parsedVars, record, userIdForTimeZone, orgId,
					cachedValues, placeholderLabel);
		}

		/// <summary>
		///     Replaces all placeholders with their values. Traverses lookups.
		/// </summary>
		/// <param name="record">
		///     The record whose values will be used to replace the placeholders.
		///     All attributes in This record should be fully loaded.
		/// </param>
		public static string ParseAttributeVariable(IOrganizationService service, string rawText,
			Entity record, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			orgId.RequireNotEmpty(nameof(orgId));

			if (string.IsNullOrEmpty(rawText))
			{
				return string.Empty;
			}

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var placeholderLabelRegex = placeholderLabel.IsNotEmpty() ? $"(?:!{placeholderLabel}!|(?!!.*?!))" : "";

			var parsedVariable = Regex.Replace(
				rawText, @"(?!{[0-9a-fA-F]{8}[-]?(?:[0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}}){" + placeholderLabelRegex +
				@"((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))(?:@((?>(?<c2>{)|[^{}]+?|(?<-c2>}))*)(?(c2)(?!)))?(?:(\$(?>(?<c3>{)|[^{}]+?|(?<-c3>}))*)(?(c3)(?!)))*}",
				match =>
				{
					if (match.Success)
					{
						var parsedInnerVariable = ParseAttributeVariables(service, match.Groups[1].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						var parsedModifier = ParseAttributeVariables(service, match.Groups[2].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						var parsedStringModifier = ParseAttributeVariables(service, match.Groups[3].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						return GetFieldValueByPathAsString(service, parsedInnerVariable, parsedModifier, parsedStringModifier,
							record, userIdForTimeZone, orgId, cachedValues) ?? string.Empty;
					}

					return rawText;
				});

			return parsedVariable == rawText
				? parsedVariable
				: ParseAttributeVariable(service, parsedVariable, record, userIdForTimeZone, orgId,
					cachedValues, placeholderLabel);
		}

		private static string BuildPlaceholderGuards(Entity record, string placeholderLabel = null)
		{
			record.Require(nameof(record));
			var noLabelRegex = $"!meta.logicalname=={record.LogicalName}!|(?!!.*?!)";
			return $"(?:{(placeholderLabel.IsNotEmpty() ? $"!{placeholderLabel}!|{noLabelRegex}" : noLabelRegex)})";
		}

		private static int CompareValues(string first, string second)
		{
			var firstValue = GetTypedValue(first);
			var secondValue = GetTypedValue(second);

			if (firstValue is IComparable firstComparable && secondValue is IComparable secondComparable)
			{
				return (firstComparable is string ? secondComparable.ToString() : secondComparable)
					.CompareTo(secondComparable is string ? firstComparable.ToString() : firstComparable);
			}

			return firstValue == secondValue ? 0 : -1;
		}

		private static object GetTypedValue(string value)
		{
			value.Require(nameof(value));

			var isConverted = decimal.TryParse(value, out var parsedDecimalValue);

			if (isConverted)
			{
				return parsedDecimalValue;
			}

			isConverted = Guid.TryParse(value, out var parsedGuidValue);

			if (isConverted)
			{
				return parsedGuidValue;
			}

			isConverted = bool.TryParse(value, out var parsedBoolValue);

			if (isConverted)
			{
				return parsedBoolValue;
			}

			isConverted = DateTime.TryParse(value, out var parsedDateValue);

			if (isConverted)
			{
				return parsedDateValue;
			}

			return value;
		}

		public static string GetFieldValueByPathAsString(IOrganizationService service,
			string rawVariable, string modifier, string stringModifier,
			Entity record, Guid userIdForTimeZone, string orgId, IDictionary<string, string> cachedValues = null)
		{
			service.Require(nameof(service));
			rawVariable.Require(nameof(rawVariable));
			record.Require(nameof(record));

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var cacheKey = $"{record.LogicalName}:{record.Id}-{rawVariable}@{modifier}${stringModifier}";
			var isCached = cachedValues.TryGetValue(cacheKey, out var cachedMatch);

			if (isCached)
			{
				return cachedMatch;
			}

			var isModified = modifier.IsNotEmpty();

			// clean the variable from its delimiters
			var variable = rawVariable.TrimStart('.');

			// get all fields in the string
			var field = variable.Split('.');

			// get the first field to fetch
			var fieldName = field[0];

			if (fieldName == "recordid")
			{
				var recordId = record.Id.ToString();
				return cachedValues[cacheKey] = ProcessStringModifier(recordId, stringModifier);
			}

			if (fieldName == "recordurl")
			{
				return cachedValues[cacheKey] =
					ProcessStringModifier(GetRecordUrl(service, record.ToEntityReference(), orgId), stringModifier);
			}

			// remove the first field from the string
			variable = string.Join(".", field.Skip(1).ToArray()).Trim('.');

			var relationMatch = Regex.Match(fieldName,
				@"^>([^()]+?)(?:\((\*)?(?:\^(\w+?)(!)?)?(?:\|([^()]*?))?\))?(?:\(([^()]+?)(==|[<>]=?|!=)([^()]+?)\))?$");

			// relation drill-through
			if (relationMatch.Value.IsNotEmpty())
			{
				var relationName = relationMatch.Groups[1].Value;
				var isDistinct = relationMatch.Groups[2].Value == "*";
				var orderingField = relationMatch.Groups[3].Value;
				var isDescending = relationMatch.Groups[4].Value == "!";
				var separator = relationMatch.Groups[5].Value;
				var conditionLeft = relationMatch.Groups[6].Value;
				var comparator = relationMatch.Groups[7].Value;
				var conditionRight = relationMatch.Groups[8].Value;

				FilterExpression filter = null;

				if (conditionLeft.IsNotEmpty())
				{
					conditionRight = conditionRight.IsNotEmpty() ? conditionRight : null;

					if (comparator.IsNotEmpty() && conditionRight.IsNotEmpty())
					{
						ConditionOperator compareOp = ConditionOperator.Equal;

						switch (comparator)
						{
							case "==":
								compareOp = ConditionOperator.Equal;
								break;
							case "<":
								compareOp = ConditionOperator.LessThan;
								break;
							case "<=":
								compareOp = ConditionOperator.LessEqual;
								break;
							case ">":
								compareOp = ConditionOperator.GreaterThan;
								break;
							case ">=":
								compareOp = ConditionOperator.GreaterEqual;
								break;
							case "!=":
								compareOp = ConditionOperator.NotEqual;
								break;
							default:
								throw new Exception($"'{relationMatch.Value}' is in an invalid format.");
						}

						filter = new FilterExpression();
						filter.AddCondition(conditionLeft, compareOp, conditionRight);
					}
					else
					{
						filter = new FilterExpression();
						filter.AddCondition(conditionLeft, ConditionOperator.NotNull);
					}
				}

				// get field name in related entity
				field = variable.Split('.');
				fieldName = field[0];
				variable = string.Join(".", field.Skip(1).ToArray()).Trim('.');

				var records = GetRelatedRecords(service, record.ToEntityReference(), relationName, orgId,
					filter, new[] { fieldName, orderingField }.Where(f => f.IsNotEmpty()).Distinct().ToArray())
					.AsQueryable();

				if (orderingField.IsNotEmpty())
				{
					records = isDescending
						? records.OrderByDescending(
							r => GetTypedValue(GetAttributeStringValue(r.GetAttributeValue<object>(orderingField))))
						: records.OrderBy(r => GetTypedValue(GetAttributeStringValue(r.GetAttributeValue<object>(orderingField))));
				}

				var relationStrings = new List<string>();

				foreach (var relatedRecord in records)
				{
					// get the field value from the entity record
					var relatedValue = relatedRecord.GetAttributeValue<object>(fieldName);

					if (relatedValue == null)
					{
						continue;
					}

					if (variable.IsNotEmpty())
					{
						// if the field value is not a lookup, then we can't recurse
						var reference = relatedValue as EntityReference;

						if (reference == null)
						{
							throw new Exception($"Field \"{fieldName}\" is not a lookup.");
						}

						var refEntity =
							new Entity(reference.LogicalName)
							{
								Id = reference.Id
							};

						relationStrings.Add(GetFieldValueByPathAsString(service, variable, modifier, stringModifier, refEntity,
							userIdForTimeZone, orgId));
					}
					else
					{
						relationStrings.Add(GetAttributeStringValue(relatedValue));
					}
				}

				return string.Join(separator, isDistinct ? relationStrings.Distinct() : relationStrings);
			}

			// get the field value from the entity record
			var fieldValue = record.GetAttributeValue<object>(fieldName);

			// get the entity record
			record = fieldValue == null
				? service.Retrieve(record.LogicalName, record.Id, new ColumnSet(fieldName))
				: record;

			fieldValue = record.GetAttributeValue<object>(fieldName);

			if (fieldValue == null)
			{
				return cachedValues[cacheKey] = null;
			}

			// variable is recursive, so we need to go deeper through the lookup
			if (variable.IsNotEmpty())
			{
				// if the field value is not a lookup, then we can't recurse
				var reference = fieldValue as EntityReference;

				if (reference == null)
				{
					throw new Exception($"Field \"{fieldName}\" is not a lookup.");
				}

				var refEntity =
					new Entity(reference.LogicalName)
					{
						Id = reference.Id
					};

				return cachedValues[cacheKey] =
					GetFieldValueByPathAsString(service, variable, modifier, stringModifier, refEntity, userIdForTimeZone, orgId);
			}

			var result = string.Empty;

			if (fieldValue is string s)
			{
				result = s;
			}

			if (fieldValue is OptionSetValue value)
			{
				string label;

				if (isModified)
				{
					label = MetadataHelpers.GetOptionSetLabel(service, record.LogicalName, fieldName,
						value.Value, orgId, int.Parse(modifier))
						?? record.FormattedValues.FirstOrDefault(keyVal => keyVal.Key == fieldName).Value;
				}
				else
				{
					label = value.Value.ToString();
				}

				result = label ?? string.Empty;
			}

			if (fieldValue is DateTime time)
			{
				if (isModified)
				{
					var date = time.ConvertToCrmUserTimeZone(service, userIdForTimeZone);
					result = string.Format($"{{0:{modifier}}}", date);
				}
				else
				{
					result = time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
				}
			}

			if (fieldValue is EntityReference fieldRef)
			{
				if (isModified)
				{
					result =
						fieldRef.Name ?? GetRecordName(service, fieldRef.LogicalName, fieldRef.Id, orgId);
				}
				else
				{
					result = fieldRef.Id.ToString().ToUpper();
				}
			}

			if (fieldValue is Guid fieldGuid)
			{
				result = fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				result = fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				fieldValue = fieldMoney.Value;
			}

			var isConverted = decimal.TryParse(fieldValue.ToString(), out var parsedDecimalValue);
			var isModifierConverted = int.TryParse(modifier, out var precision);

			if (isConverted && isModifierConverted)
			{
				result = parsedDecimalValue.ToString($"0.{new string('#', precision)}");
			}

			if (result.IsEmpty())
			{
				result = fieldValue.ToString();
			}

			return cachedValues[cacheKey] = ProcessStringModifier(result, stringModifier);
		}

		private static string ProcessStringModifier(string input, string modifiers)
		{
			var result = input;

			if (input == null)
			{
				return result;
			}

			foreach (Match match in Regex.Matches(modifiers,
				@"\$(upper|lower|title|trim|trimstart|trimend|sub|padleft|padright|replace|length|regex)(?:\(([^$]*?)\))?(?::([^$]*))?"))
			{
				var modifier = match.Groups[1].Value;
				var regexSeparator = match.Groups[2].Value;
				var parameter = match.Groups[3].Value;

				Match parameterMatch;

				switch (modifier)
				{
					case "upper":
						result = result.ToUpper();
						break;
					case "lower":
						result = result.ToLower();
						break;
					case "title":
						result = result.ToTitleCase();
						break;
					case "length":
						result = result.Length.ToString();
						break;
					case "trim":
					case "trimstart":
					case "trimend":
						if (parameter.IsNotEmpty())
						{
							if (char.TryParse(parameter, out var trimChar))
							{
								switch (modifier)
								{
									case "trim":
										result = result.Trim(trimChar);
										break;
									case "trimstart":
										result = result.TrimStart(trimChar);
										break;
									case "trimend":
										result = result.TrimEnd(trimChar);
										break;
								}
							}
						}
						else
						{
							switch (modifier)
							{
								case "trim":
									result = result.Trim();
									break;
								case "trimstart":
									result = result.TrimStart();
									break;
								case "trimend":
									result = result.TrimEnd();
									break;
							}
						}

						break;
					case "sub":
						if (parameter.IsNotEmpty())
						{
							parameterMatch = Regex.Match(parameter, @"(\d+)(?:,(\d+))?");
							var startMatch = parameterMatch.Groups[1].Value;
							var start = startMatch.IsNotEmpty() ? int.Parse(parameterMatch.Groups[1].Value) : 0;
							var lengthMatch = parameterMatch.Groups[2].Value;
							var length = lengthMatch.IsNotEmpty() ? int.Parse(lengthMatch) : result.Length;
							result = result.Substring(start, length);
						}

						break;
					case "replace":
						if (parameter.IsNotEmpty())
						{
							parameterMatch = Regex.Match(parameter, @"^""((?:[^""]|\\"")+)""(?:,""((?:[^""]|\\"")*)""$)");
							var origValue = parameterMatch.Groups[1].Value.Replace("\\\"", "\"");
							var replaceValue = parameterMatch.Groups[2].Value.Replace("\\\"", "\"");
							result = result.Replace(origValue, replaceValue);
						}

						break;
					case "padleft":
					case "padright":
						parameterMatch = Regex.Match(parameter, @"(\d+)(?:,(.))?");
						var countMatch = parameterMatch.Groups[1].Value;
						var totalWidth = countMatch.IsNotEmpty() ? int.Parse(parameterMatch.Groups[1].Value) : 0;
						var charMatch = parameterMatch.Groups[2].Value;
						var character = charMatch.IsNotEmpty() ? char.Parse(charMatch) : '\0';

						if (character != '\0')
						{
							switch (modifier)
							{
								case "padleft":
									result = result.PadLeft(totalWidth, character);
									break;
								case "padright":
									result = result.PadRight(totalWidth, character);
									break;
							}
						}
						else
						{
							switch (modifier)
							{
								case "padleft":
									result = result.PadLeft(totalWidth);
									break;
								case "padright":
									result = result.PadRight(totalWidth);
									break;
							}
						}

						break;
					case "regex":
						if (regexSeparator.IsNotEmpty() && parameter.IsNotEmpty())
						{
							var groupsStrings = new List<string>();

							foreach (Match matchT in Regex.Matches(result, parameter))
							{
								var groups = matchT.Groups;

								for (var i = 1; i < groups.Count; i++)
								{
									groupsStrings.Add(groups[i].Value);
								}
							}

							result = string.Join(regexSeparator, groupsStrings);
						}

						break;
				}
			}

			return result;
		}

		public static T GetFieldValueByPath<T>(IOrganizationService service, EntityReference entityRef, string path,
			IDictionary<string, object> cachedValues = null)
		{
			service.Require(nameof(service));
			entityRef.Require(nameof(entityRef));
			path.RequireNotEmpty(nameof(path));

			cachedValues = cachedValues ?? new Dictionary<string, object>();

			var isCached = cachedValues.TryGetValue(path, out var cachedMatch);

			if (isCached)
			{
				return (T)cachedMatch;
			}

			var fieldValue = path;
			var pathQueue = new Queue<string>();

			foreach (var match in fieldValue.Split('.'))
			{
				pathQueue.Enqueue(match);
			}

			if (pathQueue.Count <= 0)
			{
				throw new FormatException("Poorly formatted path: '" + path + "'.");
			}

			var valueRecord = service.Retrieve(entityRef.LogicalName, entityRef.Id, new ColumnSet(pathQueue.Peek()));

			while (pathQueue.Count > 1)
			{
				var pathNode = pathQueue.Dequeue();
				var valueRef = valueRecord.Attributes.FirstOrDefault(pair => pair.Key == pathNode).Value as EntityReference;

				if (valueRef == null)
				{
					return (T)(cachedValues[path] = default(T));
				}

				valueRecord = service.Retrieve(valueRef.LogicalName, valueRef.Id, new ColumnSet(pathQueue.Peek()));
			}

			var field = pathQueue.Peek();
			return (T)(cachedValues[path] =
				service.Retrieve(valueRecord.LogicalName, valueRecord.Id, new ColumnSet(field)).GetAttributeValue<T>(field));
		}

		#endregion

		public static string GetRecordUrl(IOrganizationService service, EntityReference recordRef, string orgId)
		{
			recordRef.Require(nameof(recordRef));
			orgId.RequireNotEmpty(nameof(orgId));

			var baseUrl = GetGenericConfig(service, orgId).GetAttributeValue<string>("ldv_organisationbaseurl");
			baseUrl.RequireNotEmpty(nameof(baseUrl));

			return $"{baseUrl.Trim('/')}/main.aspx"
				+ $"?etc={MetadataHelpers.GetTypeCodeUsingEntityName(service, recordRef.LogicalName, orgId)}"
				+ $"&id=%7b{recordRef.Id}%7d"
				+ $"&pagetype=entityrecord";
		}

		public static string GetAttributeStringValue(object fieldValue)
		{
			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				return fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		private static IEnumerable<Entity> GetRecords(EntityReference entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, params string[] attributes)
		{
			return RetrieveRecords(service, BuildRetrieveQuery(entity, fromEntityName, toEntityName,
				fromFieldName, toFieldName, intersectIdFieldName, filter, attributes), limit, page);
		}

		private static QueryExpression BuildRetrieveQuery(EntityReference entity,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, FilterExpression filter = null, params string[] attributes)
		{
			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity.Id);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			return query;
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class MetadataHelpers
	{
		private static readonly string[] nonStandard =
		{
			"applicationfile",
			"attachment", // Not included with CrmSvcUtil 6.0.0001.0061
			"authorizationserver", // Not included with CrmSvcUtil 6.0.0001.0061
			"businessprocessflowinstance",
			// Not included with CrmSvcUtil 2013  http://community.dynamics.com/crm/f/117/t/117642.aspx
			"businessunitmap", // Not included with CrmSvcUtil 2013
			"clientupdate", // Not included with CrmSvcUtil 2013
			"commitment", // Not included with CrmSvcUtil 2013
			"competitoraddress", // isn't include in CrmSvcUtil but it shows in the default solution
			"complexcontrol", // Not Included with CrmSvcUtil 2013
			"dependencynode", // Not Included with CrmSvcUtil 2013
			"displaystringmap", // Not Included with CrmSvcUtil 2013
			"documentindex", // Not Included with CrmSvcUtil 2013
			"emailhash", // Not Included with CrmSvcUtil 2013
			"emailsearch", // Not Included with CrmSvcUtil 2013
			"filtertemplate", // Not Included with CrmSvcUtil 2013
			"imagedescriptor", // Not included with CrmSvcUtil 2013
			"importdata", // Not included with CrmSvcUtil 6.0.0001.0061
			"integrationstatus", // Not included with CrmSvcUtil 6.0.0001.0061
			"interprocesslock", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearchentities", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearch", // Not included with CrmSvcUtil 6.0.0001.0061
			"notification", // Not included with CrmSvcUtil 6.0.0001.0061
			"organizationstatistic", // Not included with CrmSvcUtil 6.0.0001.0061
			"owner", // Not included with CrmSvcUtil 2013
			"partnerapplication", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalattributeaccessmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccessreadsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccess", // Not included with CrmSvcUtil 6.0.0001.0061
			"privilegeobjecttypecodes", // Not included with CrmSvcUtil 6.0.0001.0061
			"postregarding", // Not included with CrmSvcUtil 2013
			"postrole", // Not included with CrmSvcUtil 2013
			"subscriptionclients", // Not included with CrmSvcUtil 6.0.0001.0061
			"salesprocessinstance", // Not included with CrmSvcUtil 6.0.0001.0061
			"recordcountsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"replicationbacklog", // Not included with CrmSvcUtil 6.0.0001.0061
			"resourcegroupexpansion", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncommand", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncontextgroup", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbondiff", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbonrule", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbontabtocommandmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"roletemplate", // Not included with CrmSvcUtil 6.0.0001.0061
			"statusmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"stringmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"sqlencryptionaudit",
			"subscriptionsyncinfo",
			"subscription", // Not included with CrmSvcUtil 6.0.0001.0061
			"subscriptiontrackingdeletedobject",
			"systemapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserbusinessunitentitymap", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserprincipals", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceassociation", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceregarding", // Not included with CrmSvcUtil 6.0.0001.0061
			"unresolvedaddress", // Not included with CrmSvcUtil 6.0.0001.0061
			"userapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"userfiscalcalendar", // Not included with CrmSvcUtil 6.0.0001.0061
			"webwizard", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardaccessprivilege", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardpage", // Not included with CrmSvcUtil 6.0.0001.0061
			"workflowwaitsubscription", // Not included with CrmSvcUtil 6.0.0001.0061
			// the following cause duplicate errors in generated code
			"bulkdeleteoperation",
			"reportlink",
			"rollupjob"
		};

		public enum EntityAttribute
		{
			LogicalName,
			SchemaName,
			DisplayName,
			PrimaryIdAttribute,
			PrimaryNameAttribute,
			ObjectTypeCode,
			IsActivity,
			Keys
		}

		public enum FieldAttribute
		{
			OptionSet
		}

		public enum RelationAttribute
		{
			SchemaName,
			RelationshipType,
			ReferencedEntity,
			ReferencedAttribute,
			ReferencingEntity,
			ReferencingAttribute,
			IntersectEntityName,
			Entity1LogicalName,
			Entity1IntersectAttribute,
			Entity2LogicalName,
			Entity2IntersectAttribute
		}

		public enum RelationType
		{
			OneToManyRelationships,
			ManyToOneRelationships,
			ManyToManyRelationships
		}

		/// <summary>
		///     Checks whether the given field exists in the entity by its logical name.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsFieldExistInEntity(IOrganizationService service, string entityName, string fieldName, string orgId)
		{
			var cacheKey = $"LinDev.Common.IsFieldExistInEntity|{entityName}|{fieldName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Criteria = attributeFilter,
							Properties = attributeProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata;
			return CacheHelpers.AddToMemCache(cacheKey,
				result != null && result.Count > 0 && result.First().Attributes.Length > 0
					&& result.First().Attributes.Any(attribute => attribute.LogicalName == fieldName),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IDictionary<string, string> GetEntityNames(IOrganizationService service, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityNames";
			var entityNames = CacheHelpers.GetFromMemCache<IDictionary<string, string>>(cacheKey, orgId);

			if (entityNames != null)
			{
				return entityNames;
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				GetEntities(service, orgId, MetadataHelpers.EntityAttribute.LogicalName, MetadataHelpers.EntityAttribute.DisplayName)
					.Where(e => e.DisplayName?.UserLocalizedLabel?.Label != null)
					.OrderBy(e => e.LogicalName)
					.ToDictionary(e => e.LogicalName, e => e.DisplayName?.UserLocalizedLabel?.Label),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the given properties of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static List<EntityMetadata> GetEntities(IOrganizationService service, string orgId,
			params MetadataHelpers.EntityAttribute[] attributes)
		{
			return GetEntities(service, orgId, attributes.Select(attribute => attribute.ToString()).ToArray<string>());
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static List<EntityMetadata> GetEntities(IOrganizationService service, string orgId, params string[] attributes)
		{
			var cacheKey = $"LinDev.Common.GetEntities|{attributes.Aggregate("", (a1, a2) => a1 + "," + a2)}";
			var entities = CacheHelpers.GetFromMemCache<List<EntityMetadata>>(cacheKey, orgId);

			if (entities != null)
			{
				return entities;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};

			if (attributes?.Any() == true)
			{
				entityProperties.PropertyNames.AddRange(attributes);
			}

			var logicalNameString = MetadataHelpers.EntityAttribute.LogicalName.ToString();

			if (attributes?.Contains(logicalNameString) != true)
			{
				entityProperties.PropertyNames.Add(logicalNameString);
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata
					.Where(entity =>
					{
						if (entity.LogicalName == null)
						{
							return false;
						}

						return !nonStandard.Contains(entity.LogicalName);
					}).ToList(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the entity meta data from the metadata cache.<br />
		///     Includes: LogicalName, DisplayName, PrimaryIdAttribute, PrimaryNameAttribute, Keys,
		///     Attributes, OneToManyRelationships, ManyToOneRelationships, ManyToManyRelationships<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static EntityMetadata GetEntity(IOrganizationService service, string logicalName, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntity|{logicalName}";
			var entity = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (entity != null)
			{
				return entity;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName", "DisplayName", "PrimaryIdAttribute", "PrimaryNameAttribute",
				"Keys", "Attributes", "OneToManyRelationships", "ManyToOneRelationships", "ManyToManyRelationships");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName", "DisplayName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("AttributeOf", MetadataConditionOperator.Equals, null));

			var keyProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			keyProperties.PropertyNames.AddRange("KeyAttributes");

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange("SchemaName",
				"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
				"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
				"Entity2LogicalName", "Entity2IntersectAttribute");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						},
					KeyQuery =
						new EntityKeyQueryExpression
						{
							Properties = keyProperties
						},
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the value of an entity attribute from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetEntityAttribute<T>(IOrganizationService service, string entityName,
			MetadataHelpers.EntityAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityAttribute|{entityName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties = new MetadataPropertiesExpression
			{
				AllProperties = false
			};
			entityProperties.PropertyNames.AddRange(attribute.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals,
					entityName));

			var entityQueryExpression = new EntityQueryExpression
			{
				Criteria = entityFilter,
				Properties = entityProperties
			};

			var retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest
			{
				Query = entityQueryExpression,
				ClientVersionStamp = null
			};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();
			return CacheHelpers.AddToMemCache(cacheKey,
				(T)metadata?.GetType().GetProperty(attribute.ToString())?.GetValue(metadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the value of a list of entity attributes from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static EntityMetadata GetEntityAttributes(IOrganizationService service, string entityName,
			string orgId, params MetadataHelpers.EntityAttribute[] attributes)
		{
			var cacheKey = $"LinDev.Common.GetEntityAttributes|{entityName}|"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var attributesCached = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (attributesCached != null)
			{
				return attributesCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(attributes.Select(a => a.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Gets the logical name using the entity's object type code.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetEntityNameUsingTypeCode(IOrganizationService service, int typeCode, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityNameUsingTypeCode|{typeCode}";
			var entityName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId);

			if (entityName != null)
			{
				return entityName;
			}

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(new MetadataConditionExpression("ObjectTypeCode",
				MetadataConditionOperator.Equals, typeCode));

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault()?.LogicalName,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Gets the entity's object type code using its logical name.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetTypeCodeUsingEntityName(IOrganizationService service, string entityName,
			string orgId)
		{
			return GetEntityAttribute<int?>(service, entityName, MetadataHelpers.EntityAttribute.ObjectTypeCode, orgId) ?? 0;
		}

		/// <summary>
		///     Get the value of a field attribute from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetFieldAttribute<T>(IOrganizationService service, string entityName, string fieldName,
			MetadataHelpers.FieldAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetFieldAttribute|{entityName}|{fieldName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			AttributeMetadata fieldmetadata = null;

			if (metadata != null)
			{
				fieldmetadata = metadata.Attributes?.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)fieldmetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(fieldmetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the properties of all relations of a given type in an the entity from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<RelationMetadata> GetEntityRelations(IOrganizationService service, string entityName,
			MetadataHelpers.RelationType? type, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityRelations|{entityName}|{type}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};

				if (type == null)
				{
					entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));
				}
				else
				{
					entityProperties.PropertyNames.Add(type.ToString());
				}

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return new RelationMetadata[0];
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return BuildRelationMetadata(metadata);
		}

		/// <summary>
		///     Get the properties of the relation from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static RelationMetadata GetRelation(IOrganizationService service, string entityName, string relationName,
			string orgId)
		{
			var cacheKey = $"LinDev.Common.GetRelation|{entityName}|{relationName}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
				relationFilter.Conditions
					.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
								Criteria = relationFilter
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return null;
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return BuildRelationMetadata(metadata).FirstOrDefault();
		}

		/// <summary>
		///     Get the value of a relation attribute from the metadata cache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetRelationAttribute<T>(IOrganizationService service, string entityName, string relationName,
			MetadataHelpers.RelationType type, MetadataHelpers.RelationAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetRelationAttribute|{entityName}|{relationName}|{type}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add(type.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			if (metadata == null)
			{
				return default(T);
			}

			RelationshipMetadataBase relationMetadata = null;

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata = metadata.OneToManyRelationships.FirstOrDefault();
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata = metadata.ManyToOneRelationships.FirstOrDefault();
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata = metadata.ManyToManyRelationships.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)relationMetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(relationMetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static List<RelationshipMetadataBase> GetCustomRelationships(IOrganizationService service,
			string entityName, MetadataHelpers.RelationType[] types, MetadataHelpers.RelationAttribute[] attributes,
			string orgId)
		{
			var cacheKey = $"LinDev.Common.GetCustomRelationships|{entityName}|"
				+ $"{types.Select(t => t.ToString()).Aggregate<string>((t1, t2) => t1 + "," + t2)}"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var relations = CacheHelpers.GetFromMemCache<List<RelationshipMetadataBase>>(cacheKey, orgId);

			if (relations != null)
			{
				return relations;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(types.Select(type => type.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("IsCustomRelationship", MetadataConditionOperator.Equals, true));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attributes.Select(attribute => attribute.ToString()));
			if (!attributes.Contains(MetadataHelpers.RelationAttribute.RelationshipType))
			{
				relationProperties.PropertyNames.AddRange(MetadataHelpers.RelationAttribute.RelationshipType.ToString());
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			var relationMetadata = new List<RelationshipMetadataBase>();

			if (metadata == null)
			{
				return relationMetadata;
			}

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.OneToManyRelationships);
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToOneRelationships);
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToManyRelationships);
			}

			return CacheHelpers.AddToMemCache(cacheKey, relationMetadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static string GetOptionSetLabel(IOrganizationService service, string entityName, string fieldName,
			int value, string orgId, int? language = null)
		{
			var label = GetFieldAttribute<OptionSetMetadata>(service, entityName, fieldName, MetadataHelpers.FieldAttribute.OptionSet,
				orgId)?.Options.FirstOrDefault(optionQ => optionQ.Value == value)?.Label;

			return language == null
				? label?.UserLocalizedLabel?.Label
				: label?.LocalizedLabels?.Where(l => l.LanguageCode == language).FirstOrDefault()?.Label;
		}

		public static IEnumerable<RelationMetadata> BuildRelationMetadata(EntityMetadata entityMetadata)
		{
			IEnumerable<RelationMetadata> relationMetadata = new RelationMetadata[0];

			if (entityMetadata.OneToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.OneToManyRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.OneToManyRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToOneRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToOneRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.ManyToOneRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToManyRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.ManyToManyRelationships))
					.Where(r => r != null));
			}

			return relationMetadata;
		}

		public static RelationMetadata BuildRelationMetadata(RelationshipMetadataBase relationMetadata,
			MetadataHelpers.RelationType type)
		{
			if (relationMetadata is OneToManyRelationshipMetadata relation1NTypeSpecific
				&& type == MetadataHelpers.RelationType.OneToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relation1NTypeSpecific.SchemaName,
					Entity1Name = relation1NTypeSpecific.ReferencedEntity,
					Entity1FieldName = relation1NTypeSpecific.ReferencedAttribute,
					Entity2Name = relation1NTypeSpecific.ReferencingEntity,
					Entity2FieldName = relation1NTypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is OneToManyRelationshipMetadata relationN1TypeSpecific
				&& type == MetadataHelpers.RelationType.ManyToOneRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationN1TypeSpecific.SchemaName,
					Entity1Name = relationN1TypeSpecific.ReferencedEntity,
					Entity1FieldName = relationN1TypeSpecific.ReferencedAttribute,
					Entity2Name = relationN1TypeSpecific.ReferencingEntity,
					Entity2FieldName = relationN1TypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is ManyToManyRelationshipMetadata relationNnTypeSpecific
				&& type == MetadataHelpers.RelationType.ManyToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationNnTypeSpecific.SchemaName,
					Entity1Name = relationNnTypeSpecific.Entity1LogicalName,
					Entity1FieldName = relationNnTypeSpecific.Entity1IntersectAttribute,
					Entity2Name = relationNnTypeSpecific.Entity2LogicalName,
					Entity2FieldName = relationNnTypeSpecific.Entity2IntersectAttribute,
					IntersectingEntityName = relationNnTypeSpecific.IntersectEntityName,
					Type = type
				};
			}

			return null;
		}
	}

	/// <summary>
	///     credit: http://stackoverflow.com/a/961904/1919456 <br />
	///     Credit: http://stackoverflow.com/questions/19049514/strategy-for-logging-in-production-for-dynamics-crm-plugins
	///     <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class PluginInfo
	{
		public static string GetPluginExecutionInfo(IOrganizationService organizationService, IExecutionContext context)
		{
			try
			{
				var lines = new List<string>();

				Entity target = null;
				if (context.InputParameters.ContainsKey("Target"))
				{
					target = context.InputParameters["Target"] as Entity;

					if (target == null)
					{
						var tempTarget = (EntityReference)context.InputParameters["Target"];
						target = organizationService.Retrieve(tempTarget.LogicalName, tempTarget.Id, new ColumnSet(true));
					}
				}

				lines.Add("MessageName: " + context.MessageName);
				lines.Add("PrimaryEntityName: " + context.PrimaryEntityName);
				lines.Add("PrimaryEntityId: " + context.PrimaryEntityId);
				lines.Add("BusinessUnitId: " + context.BusinessUnitId);
				lines.Add("CorrelationId: " + context.CorrelationId);
				lines.Add("Depth: " + context.Depth);

				var contextTemp = context as IPluginExecutionContext;

				if (contextTemp != null)
				{
					lines.Add("Has Parent Context: " + (contextTemp.ParentContext != null));
				}

				lines.Add("InitiatingUserId: " + context.InitiatingUserId);
				AddParameters(lines, context.InputParameters, "Input Parameters");
				lines.Add("IsInTransaction: " + context.IsInTransaction);
				lines.Add("IsolationMode: " + context.IsolationMode);
				lines.Add("Mode: " + context.Mode);
				lines.Add("OperationCreatedOn: " + context.OperationCreatedOn);
				lines.Add("OperationId: " + context.OperationId);
				lines.Add("Organization: " + context.OrganizationName + "(" + context.OrganizationId + ")");
				AddParameters(lines, context.OutputParameters, "Output Parameters");
				AddEntityReference(lines, context.OwningExtension, "OwningExtension");
				AddEntityImages(organizationService, lines, context.PostEntityImages, "Post Entity Images");
				AddEntityImages(organizationService, lines, context.PreEntityImages, "Pre Entity Images");
				lines.Add("SecondaryEntityName: " + context.SecondaryEntityName);
				AddParameters(lines, context.SharedVariables, "Shared Variables");

				if (contextTemp != null)
				{
					lines.Add("Stage: " + contextTemp.Stage);
				}

				lines.Add("UserId: " + context.UserId);

				if (target == null || target.Attributes.Count == 0)
				{
					lines.Add("Target: Empty ");
				}
				else
				{
					lines.Add("* Target " + target.ToEntityReference().Name + " *");
					lines.AddRange(
						target.Attributes.Select(
							att =>
								"    Entity[" + att.Key + "]: " +
									GetAttributeValue(organizationService, target.LogicalName, att.Key, att.Value)));
				}

				foreach (
					var entity in
						context.InputParameters.Where(param => param.Key != "Target").Select(param => param.Value).OfType<Entity>())
				{
					lines.Add("* Entity " + entity.ToEntityReference().Name + " *");
					lines.AddRange(
						entity.Attributes.Select(
							att =>
								"    Entity[" + att.Key + "]: " +
									GetAttributeValue(organizationService, entity.LogicalName, att.Key, att.Value)));
				}

				return string.Join(Environment.NewLine, lines);
			}
			catch
			{
				return string.Empty;
			}
		}

		private static string GetAttributeValue(IOrganizationService organizationService, string logicalName, string key,
			object value)
		{
			if (value == null)
			{
				return "Null";
			}

			var type = value.GetType();

			if (type == typeof(OptionSetValue))
			{
				var retrieveOptionSetRequest =
					new RetrieveAttributeRequest
					{
						EntityLogicalName = logicalName,
						LogicalName = key,
						RetrieveAsIfPublished = true
					};

				var response = (RetrieveAttributeResponse)organizationService.Execute(retrieveOptionSetRequest);

				var metadata = response.AttributeMetadata as EnumAttributeMetadata;

				if (metadata != null)
				{
					var valueTemp = ((OptionSetValue)value).Value;
					return valueTemp + " (" +
						metadata.OptionSet.Options.First(option => option.Value == valueTemp).Label.UserLocalizedLabel.Label + ")";
				}
			}

			if (type != typeof(EntityReference))
			{
				return value.ToString();
			}

			var reference = (EntityReference)value;

			if (reference.LogicalName == null)
			{
				return value.ToString();
			}

			var primaryAttribute = ((RetrieveEntityResponse)organizationService
				.Execute(
					new RetrieveEntityRequest
					{
						EntityFilters = EntityFilters.Entity,
						LogicalName = reference.LogicalName
					})).EntityMetadata.PrimaryNameAttribute;

			return reference.Id + " (" +
				organizationService.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(primaryAttribute))
					.GetAttributeValue<string>(primaryAttribute) + ")";
		}

		private static void AddEntityReference(ICollection<string> nameValuePairs, EntityReference entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add(name + ": " + entity.Name);
			}
		}

		private static void AddEntityImages(IOrganizationService organizationService, List<string> nameValuePairs,
			EntityImageCollection images, string name)
		{
			if (images != null && images.Count > 0)
			{
				nameValuePairs.Add("** " + name + " **");
				foreach (var image in images)
				{
					if (image.Value == null || image.Value.Attributes.Count == 0)
					{
						if (image.Value != null)
						{
							nameValuePairs.Add("    Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + ": Empty");
						}
					}
					else
					{
						nameValuePairs.Add("*   Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + "   *");
						nameValuePairs.AddRange(
							image.Value.Attributes.Select(
								att =>
									"        Entity[" + att.Key + "]: " +
										GetAttributeValue(organizationService, image.Value.ToEntityReference().LogicalName, att.Key, att.Value)));
					}
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static void AddParameters(List<string> nameValuePairs, ParameterCollection parameters, string name)
		{
			if (parameters != null && parameters.Count > 0)
			{
				nameValuePairs.Add("* " + name + " *");
				nameValuePairs.AddRange(parameters.Select(param => "    Param[" + param.Key + "]: " + param.Value));
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class BpfHelpers
	{
		/// <summary>
		///     Returns all stages in the process, in order, with their names.<br />
		/// </summary>
		/// <param name="service">The service.</param>
		/// <param name="processId">The process identifier.</param>
		public static List<BpfStageInfo> GetStages(IOrganizationService service, Guid processId, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetStages|{processId}";
			var process = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					service.Retrieve("workflow", processId, new ColumnSet("xaml")),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);

			if (!process.Contains("xaml"))
			{
				return null;
			}

			var doc = new XmlDocument();
			doc.LoadXml((string)process["xaml"]);

			var stepNodes = doc.SelectNodes("//*[local-name()='Workflow']/*[local-name()='ActivityReference']" +
				"/*[local-name()='ActivityReference.Properties']/*[local-name()='Collection']" +
				"/*[local-name()='ActivityReference']/*[local-name()='ActivityReference.Properties']");

			var stages = new List<BpfStageInfo>();

			if (stepNodes == null || stepNodes.Count <= 0)
			{
				return null;
			}

			for (var i = 0; i < stepNodes.Count; i++)
			{
				var idText = stepNodes[i].SelectSingleNode("*[local-name()='String' and @*[local-name()='Key']='StageId']");
				var id = idText?.InnerText;
				var labelNode =
					stepNodes[i].SelectSingleNode("*[local-name()='Collection']/*[local-name()='StepLabel']/@Description");
				var label = labelNode?.InnerText;

				if (id != null)
				{
					stages.Add(
						new BpfStageInfo
						{
							Id = Guid.Parse(id),
							Name = label,
							Index = i
						});
				}
			}

			return stages.Any() ? stages : null;
		}

		/// <summary>
		/// Fetches the BPF entity's record related to the given record.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		public static BpfRecord GetBpfRecord(IOrganizationService service, EntityReference record, Guid processId,
			string orgId)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfRecord|{record.Id}|{processId}";
			var processRecordName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId);

			using (var context = new OrganizationServiceContext(service) { MergeOption = MergeOption.NoTracking })
			{
				if (processRecordName == null)
				{
					// can't figure out the process record name except from the process's name in the DB
					processRecordName = CacheHelpers.AddToMemCache(cacheKey,
						(from process in context.CreateQuery("workflow")
						 where (Guid)process["workflowid"] == processId
						 select (string)process["uniquename"]).FirstOrDefault(),
						CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);

					if (processRecordName == null)
					{
						throw new Exception($"Could not get the entity name of process: {processId}.");
					}
				}

				// get the special entity's record for this process and given target record
				var processRecord =
					(from processRecordQ in context.CreateQuery(processRecordName)
					 where (Guid)processRecordQ["processid"] == processId
						 && ((EntityReference)processRecordQ[$"bpf_{record.LogicalName}id"]).Id == record.Id
					 select new BpfRecord
					 {
						 LogicalName = processRecordName,
						 Id = processRecordQ.GetAttributeValue<Guid>("businessprocessflowinstanceid"),
						 ProcessId = processRecordQ.GetAttributeValue<EntityReference>("processid").Id,
						 StageId = processRecordQ.GetAttributeValue<EntityReference>("activestageid").Id,
						 TraversedPath = processRecordQ.GetAttributeValue<string>("traversedpath")
					 }).FirstOrDefault();

				// first time the record is going to this process
				return processRecord;
			}
		}

		public static List<Entity> GetBpfInstances(IOrganizationService service, EntityReference record, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstances|{record.Id}";
			return CacheHelpers.GetFromMemCache<List<Entity>>(cacheKey, orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					((RetrieveProcessInstancesResponse)service.Execute(
						new RetrieveProcessInstancesRequest
						{
							EntityId = record.Id,
							EntityLogicalName = record.LogicalName
						})).Processes.Entities.ToList(),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static Entity GetBpfInstance(IOrganizationService service, EntityReference record, Guid processId,
			string orgId)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstance|{record.Id}|{processId}";
			return CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					((RetrieveProcessInstancesResponse)service.Execute(
						new RetrieveProcessInstancesRequest
						{
							EntityId = record.Id,
							EntityLogicalName = record.LogicalName
						})).Processes.Entities
						.FirstOrDefault(e => e.GetAttributeValue<EntityReference>("processid")?.Id == processId),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static Guid? GetActiveProcessId(IOrganizationService service, EntityReference record, string orgId)
		{
			return GetBpfInstances(service, record, orgId).FirstOrDefault()?
				.GetAttributeValue<EntityReference>("processid")?.Id;
		}

		public static Guid? GetActiveStageId(IOrganizationService service, EntityReference record, string orgId)
		{
			return GetBpfInstances(service, record, orgId).FirstOrDefault()?
				.GetAttributeValue<Guid?>("processstageid");
		}

		public static void MoveStage(IOrganizationService service, EntityReference record, Guid processId, string orgId,
			bool moveBackwards = false)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));

			var instance = GetBpfInstance(service, record, processId, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id);

			Guid? targetStage = null;

			for (var i = 0; i < activePath.Length; i++)
			{
				if (activePath[i] == instance.GetAttributeValue<Guid>("processstageid"))
				{
					if (moveBackwards)
					{
						if (i <= 0)
						{
							throw new Exception("Can't move backwards from first stage in the process.");
						}

						targetStage = activePath[i - 1];
					}
					else
					{
						if (i >= activePath.Length - 1)
						{
							throw new Exception("Can't move forwards from last stage in the process.");
						}

						targetStage = activePath[i + 1];
					}

					break;
				}
			}

			if (targetStage == null)
			{
				throw new Exception($"Can't find a stage to move to. Process: '{processId}', backwards: {moveBackwards}.");
			}

			var processRecord = GetBpfRecord(service, record, processId, orgId);
			MoveToStage(service, record, processId, targetStage.GetValueOrDefault(), activePath, processRecord);
		}

		public static Guid[] GetActivePath(IOrganizationService service, Guid instanceId)
		{
			return
				((RetrieveActivePathResponse)service.Execute(
					new RetrieveActivePathRequest
					{
						ProcessInstanceId = instanceId
					})).ProcessStages.Entities
				.Select(s => s.Id).ToArray();
		}

		/// <summary>
		///     Moves the process to the given stage. The process record is cached in memory.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">The target record to set the stage in.</param>
		/// <param name="processId">The process that includes the stage.</param>
		/// <param name="stageId">The stage.</param>
		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid processId, Guid stageId,
			string orgId)
		{
			var updatedRecord =
				new Entity(record.LogicalName, record.Id)
				{
					["processid"] = processId,
					["stageid"] = stageId
				};

			var processRecord = GetBpfRecord(service, record, processId, orgId);

			// first time the record is going to this process, so invoke a change so that CRM creates a BPF record first
			if (processRecord == null)
			{
				service.Update(updatedRecord);
				processRecord = GetBpfRecord(service, record, processId, orgId);

				if (processRecord == null)
				{
					throw new Exception($"Can't find the BPF instance for process: {processId}.");
				}
			}

			var instance = GetBpfInstance(service, record, processId, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id);
			MoveToStage(service, record, processId, stageId, activePath, processRecord);
		}

		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid processId, Guid stageId,
			Guid[] activePath, BpfRecord processRecord)
		{
			var updatedRecord =
				new Entity(record.LogicalName, record.Id)
				{
					["processid"] = processId,
					["stageid"] = stageId
				};

			var stringBuilder = new StringBuilder();
			var isFoundStage = false;

			// keep previous stages
			foreach (var processStageQ in activePath)
			{
				stringBuilder.Append(processStageQ);

				if (processStageQ == stageId)
				{
					isFoundStage = true;
					break;
				}

				stringBuilder.Append(',');
			}

			if (!isFoundStage)
			{
				throw new Exception($"Couldn't find target stage '{stageId}'"
					+ $" in the active path of this process '{processId}'.");
			}

			var traversedPath = stringBuilder.ToString();

			var updatedProcessRecord = new Entity(processRecord.LogicalName) { Id = processRecord.Id };
			updatedRecord["traversedpath"] = updatedProcessRecord["traversedpath"] = traversedPath;

			service.Update(updatedProcessRecord);
			service.Update(updatedRecord);
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class SlaHelpers
	{
		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(string calendarName, DateTime startDate, int duration,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(Guid calendarId, DateTime startDate, int duration,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(string calendarName, DateTime startDate, DateTime endDate,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(Guid calendarId, DateTime startDate, DateTime endDate,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays.ToArray(), service, orgId);
		}

		private static CrmCalendar RetrieveCalender(string calendarName, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarName}";
			var calendars = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId);

			if (calendars == null)
			{
				var query =
					new QueryExpression("calendar") { ColumnSet = new ColumnSet("holidayschedulecalendarid") };
				query.Criteria.AddCondition("name", ConditionOperator.Equal, calendarName);
				query.NoLock = true;
				calendars = service.RetrieveMultiple(query).Entities;

				CacheHelpers.AddToMemCache(cacheKey, calendars, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return calendars.Select(calendar =>
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				}).FirstOrDefault();
		}

		private static CrmCalendar RetrieveCalender(Guid calendarId, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarId}";
			var calendar = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId);

			if (calendar == null)
			{
				calendar = service.Retrieve("calendar", calendarId, new ColumnSet("holidayschedulecalendarid"));
				CacheHelpers.AddToMemCache(cacheKey, calendar, DateTime.Now.AddMinutes(5), orgId);
			}

			return
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				};
		}

		private static DateTime ProcessCalendar(DateTime startDate, int duration, CrmCalendar calendar, Holiday[] holidays,
			IOrganizationService service, string orgId)
		{
			DateTime? targetDate = null;
			var defaultTarget = DateTime.UtcNow.AddMinutes(duration);


			while (targetDate == null)
			{
				var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, orgId, startDate);
				var availableSlots = GetAvailableTimeSlots(timeSlots, holidays).ToArray();

				foreach (var slot in availableSlots.Where(s => s.End > startDate))
				{
					var slotStart = slot.Start >= startDate ? slot.Start : startDate;
					var slotEnd = slot.End;
					var slotDuration = (int)((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault();

					// startDate was at the slot's end, or startDate was after the slot's end
					if (slotDuration <= 0)
					{
						continue;
					}

					if (slotDuration <= duration)
					{
						duration -= slotDuration;
						continue;
					}

					// something is wrong, assign default target date
					targetDate = slotStart?.AddMinutes(duration);
					break;
				}

				// duration > available slots
				if (targetDate == null)
				{
					var slotsEnd = timeSlots.LastOrDefault()?.End;

					// something is wrong, exit
					if (slotsEnd == null)
					{
						targetDate = defaultTarget;
					}
					else
					{
						// get more slots from CRM
						startDate = slotsEnd.Value;
					}
				}
			}

			return targetDate.Value;
		}

		private static int ProcessCalendar(DateTime startDate, DateTime endDate, CrmCalendar calendar, Holiday[] holidays,
			IOrganizationService service, string orgId)
		{
			var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, orgId, startDate, endDate);
			var availableSlots = GetAvailableTimeSlots(timeSlots, holidays).ToArray();

			return
				(from slot in availableSlots.Where(s => s.End > startDate)
				 let slotStart = slot.Start >= startDate ? slot.Start : startDate
				 let slotEnd = slot.End <= endDate ? slot.End : endDate
				 let slotDuration = (int)Math.Round(((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault())
				 where slotDuration > 0
				 select slotDuration).Sum();
		}

		private static IEnumerable<Holiday> RetrieveHolidays(EntityReference holidayRef, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveHolidays|{holidayRef}";
			var rules = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId);

			if (rules == null && holidayRef != null)
			{
				rules = service.Retrieve(holidayRef.LogicalName, holidayRef.Id, new ColumnSet(true))
					.GetAttributeValue<EntityCollection>("calendarrules").Entities;
				CacheHelpers.AddToMemCache(cacheKey, rules, DateTime.Now.AddMinutes(5), orgId);
			}

			return holidayRef == null
				? new Holiday[0]
				: rules.Select(holidayCalrule =>
						new Holiday
						{
							Start = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalstart"),
							End = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalend"),
							TimeZoneCode = holidayCalrule.GetAttributeValue<int?>("timezonecode")
						});
		}

		private static TimeInfo[] RetrieveCalendarTimeSlots(Guid calendarId, IOrganizationService service, string orgId,
			DateTime startDate, DateTime? endDate = null)
		{
			startDate = startDate.Date;
			endDate = endDate?.AddDays(1).Date ?? startDate.AddDays(30);

			var cacheKey = $"Yagasoft.Common.RetrieveCalendarTimeSlots|{calendarId}|{startDate}|{endDate}";
			var slots = CacheHelpers.GetFromMemCache<TimeInfo[]>(cacheKey, orgId);

			if (slots == null)
			{
				slots = ((ExpandCalendarResponse)service.Execute(
					new ExpandCalendarRequest
					{
						CalendarId = calendarId,
						Start = startDate,
						End = endDate.Value
					})).result;
				CacheHelpers.AddToMemCache(cacheKey, slots, DateTime.Now.AddMinutes(5), orgId);
			}

			return slots;
		}

		private static IEnumerable<TimeInfo> GetAvailableTimeSlots(TimeInfo[] timeSlots, IEnumerable<Holiday> holidays)
		{
			return
				from timeSlotQ in timeSlots
				where holidays?.Any(holiday => holiday.Start < timeSlotQ.Start && holiday.End > timeSlotQ.End) != true
				select timeSlotQ;
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class FetchXmlTriggerHelpers
	{
		/// <summary>
		/// Register steps to handle FetchXML condition changes.<br />
		/// If you only care about satisfaction of conditions, then only pass plugin configs for post-operations.<br />
		/// If you need to check for negative/dissatisfaction of conditions, use pre and post-operations,
		/// passing the list of 'root' record IDs from the pre to the post plugin through the SharedVariables object.<br />
		/// You must mark the 'root' plugin, which can be common with other triggers.<br />
		/// 'GetFilteredTriggerConfigs' method can be used to get the serialised trigger config from the plugin config,
		/// which contains the FetchXML used for fetching the 'root' records.
		/// </summary>
		public static void RegisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, string orgId)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, orgId);
		}

		public static void UnregisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, string orgId)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, orgId, true);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(string pluginConfig, params string[] fields)
		{
			return GetFilteredTriggerConfigs(ParseTriggerConfigs(pluginConfig), fields);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(IEnumerable<TriggerConfig> triggerConfigs,
			params string[] fields)
		{
			return triggerConfigs.Where(t => fields.Contains("*") || fields.Intersect(t.Fields).Any());
		}

		private static void RegisterTriggeringStep(IOrganizationService service, TriggerConfigPlugin[] pluginConfigs,
			List<TriggerConfig> triggerConfigs, string orgId, bool isRemoveCurrent = false)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			triggerConfigs.Require(nameof(triggerConfigs));

			foreach (var triggerConfig in triggerConfigs)
			{
				var id = triggerConfig.Id;
				var entityName = triggerConfig.EntityName;

				foreach (var pluginConfig in pluginConfigs)
				{
					if (triggerConfig.IsRootEntity != pluginConfig.IsRootEntity)
					{
						continue;
					}

					var step = GetStep(service, GetStepName(pluginConfig.Type, pluginConfig.Message, entityName));

					// get existing entity map from plugin configuration
					var stepConfig = step?.GetAttributeValue<string>("configuration");
					var parsedStepConfig = stepConfig == null
						? new List<TriggerConfig>()
						: ParseTriggerConfigs(stepConfig).Where(c => c.Id != id).ToList();

					foreach (var config in parsedStepConfig.Where(c => string.IsNullOrWhiteSpace(c.EntityName)))
					{
						config.EntityName = entityName;
					}

					if (!isRemoveCurrent)
					{
						parsedStepConfig.Add(triggerConfig);
					}

					if (pluginConfig.ExtraTriggerFields?.Any() == true)
					{
						foreach (var field in pluginConfig.ExtraTriggerFields)
						{
							triggerConfig.Fields.Add(field);
						}
					}

					var filteredStepConfigs = parsedStepConfig.Where(c => c.Fields.Any()).ToArray();

					var parsedStepConfigString = filteredStepConfigs
						.Select(c => $"{c.Id}|||{c.IsRootEntity}|||{c.Fields.StringAggregate()}"
							+ $"{(c.IsRootEntity ? "" : $"|||{c.FetchXml.StringAggregate("^^^")}")}")
						.Aggregate("", (c1, c2) => $"{c1};;;{c2}").Trim(',', ';');

					string[] filteringAttributes = null;

					if (pluginConfig.Message == "Update")
					{
						filteringAttributes = filteredStepConfigs.SelectMany(c => c.Fields).Distinct().ToArray();
					}

					RegisterStep(service, entityName, pluginConfig, parsedStepConfigString, orgId, filteringAttributes);
				}
			}
		}

		private static IEnumerable<TriggerConfig> ParseTriggerConfigs(string rawString)
		{
			rawString.RequireNotEmpty(nameof(rawString));

			return rawString.Decompress()
				.Split(new[] { ";;;" }, StringSplitOptions.RemoveEmptyEntries)
				.Select(c => c.Split(new[] { "|||" }, StringSplitOptions.RemoveEmptyEntries))
				.Where(c => c.Any() && !string.IsNullOrWhiteSpace(c[0]))
				.Select(c =>
					new TriggerConfig
					{
						Id = c[0],
						IsRootEntity = c.Length > 1 && bool.Parse(c[1]),
						Fields = c.Length > 2 ? new HashSet<string>(c[2].Split(',')) : new HashSet<string>(),
						FetchXml = c.Length > 3
							? c[3].Split(new[] { "^^^" }, StringSplitOptions.RemoveEmptyEntries).ToList()
							: new List<string>()
					});
		}

		private static void ParseConditionFields(IOrganizationService service, string id, string fetchXml,
			List<TriggerConfig> triggerConfigs, string orgId)
		{
			fetchXml.RequireNotEmpty(nameof(fetchXml));
			triggerConfigs.Require(nameof(triggerConfigs));

			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var parentNodes = doc.SelectNodes("//entity")?.Cast<XmlNode>().ToList();

			if (parentNodes == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var linkNodes = doc.SelectNodes("//link-entity")?.Cast<XmlNode>().ToList();

			if (linkNodes != null)
			{
				parentNodes.AddRange(linkNodes);
			}

			foreach (var parent in parentNodes)
			{
				var conditionNodes = parent?.SelectNodes("filter//condition")?.Cast<XmlNode>();

				if (conditionNodes == null)
				{
					continue;
				}

				foreach (var node in conditionNodes)
				{
					var entityName = parent.Attributes?["name"]?.Value;
					var attributeName = node.Attributes?["attribute"]?.Value;

					if (entityName == null || attributeName == null)
					{
						continue;
					}

					var isRoot = parent.Name == "entity";
					var triggerConfig = triggerConfigs
							.FirstOrDefault(c => c.IsRootEntity == isRoot && c.EntityName == entityName);

					if (triggerConfig == null)
					{
						triggerConfig =
							new TriggerConfig
							{
								Id = id,
								IsRootEntity = isRoot,
								EntityName = entityName,
								FetchXml = new List<string>(),
								Fields = new HashSet<string>()
							};
						triggerConfigs.Add(triggerConfig);
					}

					triggerConfig.Fields.Add(attributeName);

					var xmlParser = new XmlDocument();
					var primaryIdField = MetadataHelpers.GetEntityAttribute<string>(service, entityName,
						MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

					xmlParser.LoadXml("<temp><filter>"
						+ $@"<condition attribute=""{primaryIdField}"" operator=""eq"" value=""{{{{recordId}}}}""/></filter></temp>");

					var tempXmlNodes = xmlParser.SelectSingleNode("/temp")?.ChildNodes.Cast<XmlNode>();
					var newXmlNodes = new List<XmlNode>();

					if (tempXmlNodes != null)
					{
						foreach (var tempNode in tempXmlNodes)
						{
							var newNode = parent.OwnerDocument?.ImportNode(tempNode, true);
							newXmlNodes.Add(newNode);

							if (newNode != null)
							{
								parent.AppendChild(newNode);
							}
						}
					}

					var newFetchXml = doc.OuterXml;
					triggerConfig.FetchXml.Add(newFetchXml);

					foreach (var newXmlNode in newXmlNodes)
					{
						parent.RemoveChild(newXmlNode);
					}
				}
			}
		}

		private static void RegisterStep(IOrganizationService service, string entity, TriggerConfigPlugin pluginConfig,
			string unsecureConfig, string orgId, params string[] filteringAttributes)
		{
			service.Require(nameof(service));
			entity.RequireNotEmpty(nameof(entity));
			pluginConfig.Require(nameof(pluginConfig));

			var message = GetMessage(service, entity, pluginConfig.Message, orgId);

			if (message == null)
			{
				throw new Exception($"Couldn't find a message '{pluginConfig.Message}' for entity '{entity}'.");
			}

			var query =
				new QueryExpression("plugintype")
				{
					Distinct = true,
					NoLock = true,
					ColumnSet = new ColumnSet("name", "plugintypeid")
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, pluginConfig.Type);

			var type = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new
					{
						e.Id,
						Name = e.GetAttributeValue<string>("name")
					}).FirstOrDefault();

			if (type == null)
			{
				throw new Exception($"Couldn't find '{pluginConfig.Type}' plugin type.");
			}

			message.PluginTypeId = type.Id;
			message.TypeName = type.Name;

			var stepName = GetStepName(message.TypeName, message.MessageName, entity);
			var step = GetStep(service, stepName);

			if (string.IsNullOrWhiteSpace(unsecureConfig))
			{
				if (step != null)
				{
					service.Delete("sdkmessageprocessingstep", step.Id);
				}
			}
			else
			{
				step = step
					?? new Entity("sdkmessageprocessingstep")
					{
						["name"] = stepName,
						["rank"] = 999,
						["stage"] = new OptionSetValue((int)pluginConfig.Stage),
						["supporteddeployment"] = new OptionSetValue(0),
						["sdkmessageid"] = new EntityReference("sdkmessage", message.MessageId),
						["sdkmessagefilterid"] = new EntityReference("sdkmessagefilter", message.FilteredId),
						["eventhandler"] = new EntityReference("plugintype", message.PluginTypeId)
					};

				step["configuration"] = unsecureConfig.Compress();

				if (filteringAttributes?.Any() == true)
				{
					step["filteringattributes"] = filteringAttributes.Aggregate("", (f1, f2) => $"{f1},{f2}").Trim(',', ';');
				}

				if (pluginConfig.Mode == PluginMode.Asynchronous)
				{
					step["asyncautodelete"] = true;
				}

				step["mode"] = new OptionSetValue((int)pluginConfig.Mode);

				if (step.Id == Guid.Empty)
				{
					var stepId = service.Create(step);

					if (pluginConfig.IsPreImage || pluginConfig.IsPostImage)
					{
						RegisterImage(service, pluginConfig, stepId);
					}
				}
				else
				{
					service.Update(step);
				}
			}
		}

		private static void RegisterImage(IOrganizationService service, TriggerConfigPlugin pluginConfig, Guid stepId)
		{
			service.Require(nameof(service));
			pluginConfig.Require(nameof(pluginConfig));

			int imageType;

			if (pluginConfig.IsPreImage && !pluginConfig.IsPostImage)
			{
				imageType = 0;
			}
			else if (!pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 1;
			}
			else if (pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 2;
			}
			else
			{
				throw new ArgumentOutOfRangeException("ImageType", "Image type is not supported.");
			}

			var image =
				new Entity("sdkmessageprocessingstepimage")
				{
					["name"] = "image",
					["entityalias"] = "image",
					["imagetype"] = new OptionSetValue(imageType),
					["messagepropertyname"] = pluginConfig.Message == "Create" ? "Id" : "Target",
					["sdkmessageprocessingstepid"] = new EntityReference("sdkmessageprocessingstep", stepId)
				};
			service.Create(image);
		}

		private static SdkMessageInfo GetMessage(IOrganizationService service, string entityName, string messageName,
			string orgId)
		{
			service.Require(nameof(service));
			entityName.RequireNotEmpty(nameof(entityName));
			messageName.RequireNotEmpty(nameof(messageName));

			var query =
				new FetchExpression("<fetch no-lock='true' >" +
					"  <entity name='sdkmessage' >" +
					"    <attribute name='name' />" +
					"    <attribute name='sdkmessageid' />" +
					"    <filter>" +
					$"      <condition attribute='name' operator='eq' value='{messageName}' />" +
					"    </filter>" +
					"    <link-entity name='sdkmessagefilter' from='sdkmessageid' to='sdkmessageid' alias='messagefilter' >" +
					"      <attribute name='sdkmessagefilterid' />" +
					"      <filter>" +
					"        <condition attribute='primaryobjecttypecode' operator='eq'"
					+ $" value='{MetadataHelpers.GetTypeCodeUsingEntityName(service, entityName, orgId)}' />" +
					"      </filter>" +
					"    </link-entity>" +
					"  </entity>" +
					"</fetch>");

			var message = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new SdkMessageInfo
					{
						MessageId = e.GetAttributeValue<Guid>("sdkmessageid"),
						MessageName = e.GetAttributeValue<string>("name"),
						FilteredId = (Guid)
							(e.GetAttributeValue<AliasedValue>("messagefilter.sdkmessagefilterid")?.Value ?? Guid.Empty)
					}).FirstOrDefault();

			if (message == null || message.MessageId == Guid.Empty || message.FilteredId == Guid.Empty)
			{
				throw new Exception($"Couldn't find {messageName} message for entity '{entityName}'.");
			}

			return message;
		}

		private static Entity GetStep(IOrganizationService service, string stepName)
		{
			service.Require(nameof(service));
			stepName.RequireNotEmpty(nameof(stepName));

			var query =
				new QueryExpression("sdkmessageprocessingstep")
				{
					NoLock = true,
					ColumnSet = new ColumnSet(true)
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, stepName);
			return service.RetrieveMultiple(query).Entities.FirstOrDefault();
		}

		private static string GetStepName(string typeName, string messageName, string entityName)
		{
			var builder = new StringBuilder();
			builder.Append("FetchXmlTrigger: ");
			builder.Append(typeName);
			builder.Append(": ");
			builder.Append(messageName);
			builder.Append(" of ");
			builder.Append(entityName == "none" ? "any entity" : entityName);

			return builder.ToString();
		}
	}

	public class CacheParams
	{
		public string OrgId;
		public string CacheSuffix;
		public DateTime CacheExpiryTarget;
	}

	public class SdkMessageInfo
	{
		public Guid MessageId;
		public Guid FilteredId;
		public string MessageName;
		public Guid PluginTypeId;
		public string TypeName;
	}

	public class TriggerConfig
	{
		public string Id;
		public bool IsRootEntity;
		public string EntityName;
		public HashSet<string> Fields;
		public List<string> FetchXml;
	}

	public class TriggerConfigPlugin
	{
		public string Type;
		public string Message;
		public bool IsRootEntity;
		public PluginStage Stage;
		public PluginMode Mode;
		public bool IsPreImage;
		public bool IsPostImage;
		public string[] ExtraTriggerFields;
	}

	public class CrmCalendar
	{
		public Guid Id;
		public EntityReference HolidayRef;
	}

	public class Holiday
	{
		public DateTime Start;
		public DateTime End;
		public int? TimeZoneCode;
	}

	public class RetrievePagingInfo
	{
		public string Cookie
		{
			get; set;
		}

		public int NextPage { get; set; } = 1;

		public int RecordCountLimit { get; set; } = -1;

		public bool IsMoreRecords { get; set; } = true;
	}

	public class BpfRecord
	{
		public Guid Id
		{
			get; set;
		}
		public string LogicalName
		{
			get; set;
		}
		public Guid? ProcessId
		{
			get; set;
		}
		public Guid? StageId
		{
			get; set;
		}
		public string TraversedPath
		{
			get; set;
		}

	}

	public class BpfStageInfo
	{
		public Guid Id
		{
			get; set;
		}

		public string Name
		{
			get; set;
		}

		public int Index
		{
			get; set;
		}
	}

	public class ExecuteBulkResponse
	{
		public OrganizationResponse Response
		{
			get; set;
		}

		public Type RequestType
		{
			get; set;
		}

		public Type ResponseType
		{
			get; set;
		}

		public OrganizationServiceFault Fault
		{
			get; set;
		}

		public string FaultMessage
		{
			get; set;
		}
	}

	public class EntityComparer : IEqualityComparer<Entity>
	{
		public bool Equals(Entity x, Entity y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(Entity obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class EntityRefComparer : IEqualityComparer<EntityReference>
	{
		public bool Equals(EntityReference x, EntityReference y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(EntityReference obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class RelationMetadata
	{
		public string SchemaName
		{
			get; set;
		}
		public string Entity1Name
		{
			get; set;
		}
		public string Entity1FieldName
		{
			get; set;
		}
		public string Entity2Name
		{
			get; set;
		}
		public string Entity2FieldName
		{
			get; set;
		}
		public MetadataHelpers.RelationType Type
		{
			get; set;
		}
		public string IntersectingEntityName
		{
			get; set;
		}
	}

	/// <summary>
	///     Unlike <see cref="Semaphore" />, this implementation ensures that holds are released in the order of acquiring the
	///     hold.
	///     It also implements <see cref="IDisposable" />, but in a reusable fashion; e.g:
	///     <code>	using (fifoSemaphore.GetPermit())
	/// 	{
	///  		// code ...
	///   	}
	///     </code>
	///     After exiting the 'using' block, <see cref="ReleasePermit" /> is called automatically.<br />
	///     Author: Ahmed Elsawalhy (Yagasoft)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class FifoSemaphore : IDisposable
	{
		private readonly Queue<ManualResetEvent> threadLocksQueue = new Queue<ManualResetEvent>();

		private readonly int maxConcurrency;

		private readonly object lockObject = new object();
		private int currentRequests;

		public FifoSemaphore(int maxConcurrency)
		{
			this.maxConcurrency = maxConcurrency;
		}

		public void Dispose()
		{
			ReleasePermit();
		}

		/// <summary>
		///     Check how many permits have been requested before, and if the number is greater than the limit,
		///     hold this request until a permit elsewhere is released.
		/// </summary>
		public FifoSemaphore AcquirePermit()
		{
			lock (lockObject)
			{
				currentRequests++;

				// if the limit hasn't been reached yet, note it, and give permission
				if (currentRequests <= maxConcurrency)
				{
					return this;
				}
			}

			using (var newLock = new ManualResetEvent(false))
			{
				// we have to wait for a slot to open
				threadLocksQueue.Enqueue(newLock);
				newLock.WaitOne();
			}

			return this;
		}

		/// <summary>
		///     Release a permit, and release the hold on the next in line.
		/// </summary>
		public void ReleasePermit()
		{
			lock (lockObject)
			{
				// note the release
				currentRequests--;

				// give permission to the next in line
				if (threadLocksQueue.Any())
				{
					threadLocksQueue.Dequeue().Set();
				}
			}
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940 <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class QueuedLock : IDisposable
	{
		private readonly object innerLock;
		private volatile int ticketsCount;
		private volatile int ticketToRide;

		public QueuedLock()
		{
			innerLock = new object();
			ticketToRide = ticketsCount + 1;
		}

		public void Dispose()
		{
			Exit();
		}

		public QueuedLock Enter()
		{
			var myTicket = Interlocked.Increment(ref ticketsCount);
			Monitor.Enter(innerLock);

			while (true)
			{
				if (myTicket == ticketToRide)
				{
					return this;
				}

				Monitor.Wait(innerLock);
			}
		}

		public void Exit()
		{
			Interlocked.Increment(ref ticketToRide);
			Monitor.PulseAll(innerLock);
			Monitor.Exit(innerLock);
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class BlockingQueue<T> : BlockingCollection<T>
	{
		#region ctor(s)

		public BlockingQueue()
			: base(new ConcurrentQueue<T>())
		{
		}

		public BlockingQueue(int maxSize)
			: base(new ConcurrentQueue<T>(), maxSize)
		{
		}

		#endregion ctor(s)

		#region Methods

		/// <summary>
		///     Enqueue an Item
		/// </summary>
		/// <param name="item">Item to enqueue</param>
		/// <remarks>blocks if the blocking queue is full</remarks>
		public void Enqueue(T item)
		{
			Add(item);
		}

		/// <summary>
		///     Dequeue an item
		/// </summary>
		/// <returns>Item dequeued</returns>
		/// <remarks>blocks if the blocking queue is empty</remarks>
		public T Dequeue()
		{
			return Take();
		}

		/// <summary>
		///     Clears the queue of all items
		/// </summary>
		public void Clear()
		{
			while (this.Any())
			{
				Dequeue();
			}
		}

		#endregion Methods
	}

	#endregion

	#region CrmLog

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogAttribute : Attribute
	{
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class NoLogAttribute : Attribute
	{
	}

	/// <summary>
	///     Receives log entries and saves them to CRM, disk, or output to console.<br />
	///     Author: Ahmed Elsawalhy<br />
	///     Version: 4.1.2
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class CrmLog
	{
		#region Fields

		private readonly string configMemCacheKey = $"CrmLoggerConfig";
		private readonly string orgId;
		private readonly bool isSandboxMode;
		private readonly bool isPlugin;
		private Entity parentLog;
		private bool exceptionThrown;
		private LogEntry exceptionLogEntry;
		private Queue<LogEntry> logQueue;
		private Queue<LogEntry> offlineQueue;
		private Stack<LogEntry> execSeqStack;
		private Stopwatch executionTimer;
		private Stack<Stopwatch> functionTimersStack;
		private Stack<int> durationsStack;
		private bool isConsoleEnabled;
		private bool isAutoLogToConsole;
		private bool isParentCreated;
		private bool? isBulkPreviously;

		#endregion

		#region Constructors

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			InitialiseLog(null, maximumLevel, callingFunction);
			IsOfflineOnly = true;
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(IOrganizationService organizationService, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			InitialiseLog(organizationService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="userId">The ID of the user that is going to be set in the logs</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(IOrganizationService organizationService, Guid userId,
			LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			UserId = userId;
			InitialiseLog(organizationService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="serviceProvider">The service provider from a plugin.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(IServiceProvider serviceProvider, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			serviceProvider.Require(nameof(serviceProvider));

			var context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId.ToString();
			configMemCacheKey += $"|{orgId}";

			var service = ((IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory)))
				.CreateOrganizationService(null);

			InitialiseLog(service, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="activityContext">The activity context from a custom step.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(ActivityContext activityContext, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			activityContext.Require(nameof(activityContext));

			var context = activityContext.GetExtension<IWorkflowContext>();
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId.ToString();
			configMemCacheKey += $"|{orgId}";

			InitialiseLog(activityContext.GetExtension<IOrganizationServiceFactory>()
				.CreateOrganizationService(null), maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="path">[OPTIONAL] The path.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public CrmLog(string path = "", LogLevel? maximumLevel = null, FileConfiguration config = null,
			[CallerMemberName] string callingFunction = "")
		{
			IsOfflineOnly = true;
			InitialiseLog(null, maximumLevel, callingFunction);
			InitOfflineLog(path, false, config);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="isAutoLog">If 'true', automatically output log entries to the console.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public CrmLog(bool isAutoLog, LogLevel? maxLogLevel = null, [CallerMemberName] string callingFunction = "")
		{
			IsOfflineOnly = true;
			InitialiseLog(null, maxLogLevel, callingFunction);
			MaxConsoleLogLevel = maxLogLevel ?? LogLevel.Info;
			IsConsoleEnabled = true;
			IsAutoLogToConsole = isAutoLog;
		}

		protected CrmLog()
		{
		}

		#endregion

		/// <summary>
		///     The end states of the program that contains the logging object
		/// </summary>
		public enum ExecutionEndState
		{
			Success = 0,
			Failure = 1
		}

		#region Instance variables

		public IOrganizationService OrganizationService
		{
			get; private set;
		}

		public Guid UserId
		{
			get; private set;
		}

		public FileConfiguration Config
		{
			get; private set;
		}

		public LogLevel MaxLogLevel
		{
			get; private set;
		}

		public ExecutionEndState AssemblyExecutionState
		{
			get; private set;
		}

		public int CurrentEntryIndex
		{
			get; private set;
		}

		public DateTime LogStartDate
		{
			get; private set;
		}

		public bool ExecutionStarted
		{
			get; private set;
		}

		public string OfflinePath
		{
			get; private set;
		}

		public bool IsOfflineEnabled
		{
			get; private set;
		}

		public bool IsFailOver
		{
			get; private set;
		}

		public bool IsOfflineOnly
		{
			get; private set;
		}

		public LogLevel MaxConsoleLogLevel
		{
			get; private set;
		}

		public bool IsConsoleEnabled
		{
			get
			{
				return isConsoleEnabled;
			}

			private set
			{
				isConsoleEnabled = value;
				isAutoLogToConsole = isConsoleEnabled && IsAutoLogToConsole;
			}
		}

		public bool IsAutoLogToConsole
		{
			get
			{
				return isAutoLogToConsole;
			}

			private set
			{
				isAutoLogToConsole = value;
				isConsoleEnabled = isAutoLogToConsole || IsConsoleEnabled;
			}
		}

		public event EventHandler<LogEntryAddedEventArgs> LogEntryAdded;

		#endregion

		#region Init

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, string regardingId, string regardingName = "")
		{
			parentLog["ldv_regardingtype"] = regardingType;
			parentLog["ldv_regardingid"] = regardingId;
			parentLog["ldv_regardingname"] = regardingName;
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, Guid regardingId, string regardingName = "")
		{
			SetRegarding(regardingType, regardingId.ToString(), regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regarding">The reference to the concerned entity.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(EntityReference regarding, string regardingName = "")
		{
			regarding.Require(nameof(regarding));
			SetRegarding(regarding.LogicalName, regarding.Id, regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		public void SetRegarding(Entity regarding, string primaryFieldName = null)
		{
			try
			{
				regarding.Require(nameof(regarding));
				var nameField = string.IsNullOrWhiteSpace(primaryFieldName) && MaxLogLevel == LogLevel.Debug
					? MetadataHelpers.GetEntityAttribute<string>(OrganizationService, regarding.LogicalName,
						MetadataHelpers.EntityAttribute.PrimaryNameAttribute, configMemCacheKey)
					: primaryFieldName;
				var name = regarding.GetAttributeValue<string>(nameField)
					?? (MaxLogLevel == LogLevel.Debug
						? CrmHelpers.GetRecordName(OrganizationService, regarding.LogicalName, regarding.Id, nameField,
							configMemCacheKey)
						: string.Empty);
				SetRegarding(regarding.ToEntityReference(), name);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Sets the title field in the parent log.
		/// </summary>
		/// <param name="title">Title to set.</param>
		public void SetTitle(string title)
		{
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the title field in the parent log in the format 'Log for "{name}".'.
		/// </summary>
		/// <param name="name">Name of the record.</param>
		public void SetDefaultTitle(string name)
		{
			SetTitle("Log for \"" + name + "\".");
		}

		/// <summary>
		///     Sets the title field in the parent log. Also, sets the regarding with the primary name.<br />
		///     Pass a format with '{name}' to be replaced by record name.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		/// <param name="titleTemplate">[OPTIONAL=null]If null, uses 'Log for "{name}".'.</param>
		public void SetTitle(Entity regarding, string primaryFieldName = null, string titleTemplate = null)
		{
			SetRegarding(regarding, primaryFieldName);

			var name = parentLog.GetAttributeValue<string>("ldv_regardingname");

			if (string.IsNullOrWhiteSpace(name))
			{
				return;
			}

			var title = (string.IsNullOrWhiteSpace(titleTemplate) ? "Log for \"{name}\"." : titleTemplate)
				.Replace("{name}", name);
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the entry class of the parent log.
		/// </summary>
		public void SetEntryClass(string entryClass = null)
		{
			parentLog["ldv_entryclass"] = entryClass ?? Helpers.GetClassName(-1, "CrmLog");
		}

		/// <summary>
		///     Initializes the offline log.
		/// </summary>
		/// <param name="logPath">
		///     [OPTIONAL] The file to log to. Should be absolute path in the file system.
		///     Logs to C:\Logs\[assemblyName].csv by default.
		/// </param>
		/// <param name="isFailOver">[OPTIONAL] If 'true', only log to file if CRM is unavailable.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public void InitOfflineLog(string logPath = "", bool isFailOver = true, FileConfiguration config = null)
		{
			Config = config;
			OfflinePath = logPath;
			IsFailOver = isFailOver;
			IsOfflineEnabled = true;
		}

		/// <summary>
		///     Initializes console logging.
		/// </summary>
		/// <param name="isAutoLog">[OPTIONAL] If 'true', automatically output log entries to the console. Default is 'true'.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public void InitConsoleLog(bool isAutoLog = true, LogLevel maxLogLevel = LogLevel.Info)
		{
			MaxConsoleLogLevel = maxLogLevel;
			IsConsoleEnabled = true;
			IsAutoLogToConsole = isAutoLog;
		}

		#endregion

		#region Function start/end logging

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				LogExecutionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				ExecutionStarted = true;

				var defaultMessage = "Started execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set as root in call sequence
				execSeqStack.Push(logEntry);

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring execution duration
				executionTimer = Stopwatch.StartNew();

				// push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				LogFunctionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Started: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// set the parent as the previous in the stack, and set as parent in call sequence for next entries
				logEntry.ParentLogEntry = execSeqStack.Peek();
				execSeqStack.Push(logEntry);

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring function duration
				functionTimersStack.Push(Stopwatch.StartNew());
				executionTimer = executionTimer ?? functionTimersStack.Peek(); // keep the first timer to log execution time
																			   // push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				LogFunctionEnd(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				// stop function timer and get the elapsed time
				functionTimersStack.Peek().Stop();
				var elapsedTime = (int)functionTimersStack.Pop().ElapsedMilliseconds;

				// remove the duration reference of the function
				durationsStack.Pop();

				var defaultMessage = "Finished: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				execSeqStack.Pop();
				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), elapsedTime,
					true, callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending execution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(string message, bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), callingFunction, callingLineNumber);
			}
			catch (FlushException e)
			{
				throw new Exception(e.Message);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="message">[Optional] The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(ExecutionEndState state, string message = "", bool autoFlush = true,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), callingFunction, callingLineNumber);
			}
			catch (FlushException e)
			{
				throw new Exception(e.Message);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			LogEntry logEntry = null,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// stop execution timer
				executionTimer.Stop();

				// remove the duration reference of the function
				durationsStack.Pop();

				AssemblyExecutionState = (AssemblyExecutionState == ExecutionEndState.Failure) ? AssemblyExecutionState : state;

				var defaultMessage = "Finished execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Pop();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
					(int)executionTimer.ElapsedMilliseconds, true, callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
			finally
			{
				if (autoFlush)
				{
					Flush();
				}
			}
		}

		#endregion

		#region Logging Helpers

		public void LogError(string message, string information = null)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Error);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Error, string.Empty, string.Empty, information));
			}
		}

		public void LogError(Exception exception, IExecutionContext context = null)
		{
			if (context == null)
			{
				Log(exception);
			}
			else
			{
				Log(exception, context);
			}
		}

		public void LogWarning(string message, string information = null)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Warning);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Warning, string.Empty, string.Empty, information));
			}
		}

		public void LogInfo(string message, string information = null)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Info, string.Empty, string.Empty, information));
			}
		}

		public void LogDebug(string message, string information = null)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Debug);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Debug, string.Empty, string.Empty, information));
			}
		}

		#endregion

		#region Logging

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="level">[Optional] The logging level, above which, this entry will be skipped</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(string message, LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				Log(new LogEntry(message, level), regardingType, regardingName, context,
					callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), null, false,
					callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(Exception exception, IExecutionContext context, string regardingType = "",
			string regardingName = "", string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				Log(new LogEntry(exception, exception.Message), regardingType, regardingName, context,
					callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), null, false,
					callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="information">
		///     [Optional] Extra information to add to the log entry (in this case, it should be the context
		///     parse)
		/// </param>
		public void Log(Exception exception, string regardingType = "", string regardingName = "", string information = "",
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				Log(new LogEntry(exception, exception.Message, information: information), regardingType, regardingName,
					callingClass: callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace: stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(LogEntry logEntry, string regardingType = "", string regardingName = "",
			IExecutionContext context = null, string callingClass = null, string stackTrace = null, int? elapsedTime = null,
			bool parent = false, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// set parent of this entry to top of the stack entry
				if (!parent)
				{
					logEntry.Require(nameof(logEntry));
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				// calculate the duration between the last log entry in this function and this one
				if (elapsedTime == null)
				{
					// get the last recorded duration since function start
					var lastDuration = durationsStack.Pop();

					// get the function timer
					var functionDuration
						= (int)(functionTimersStack.Any()
							? functionTimersStack.Peek().ElapsedMilliseconds
							: executionTimer.ElapsedMilliseconds);

					// add a snapshot
					durationsStack.Push(functionDuration);

					// calculate the time it took to get from the last recorded entry to this entry
					logEntry.ElapsedTime = functionDuration - lastDuration;
				}
				else
				{
					logEntry.ElapsedTime = elapsedTime.Value;
				}

				logEntry.StartDate = DateTime.UtcNow.AddMilliseconds(-logEntry.ElapsedTime);

				logEntry.RegardingType = regardingType ?? logEntry.RegardingType;
				logEntry.RegardingName = regardingName ?? logEntry.RegardingName;

				// exception flag
				if (logEntry.Exception != null)
				{
					exceptionThrown = true;
					logEntry.ExceptionThrown = true;
				}

				if (logEntry.ExceptionThrown)
				{
					var logEntryTemp = logEntry;

					while ((logEntryTemp = logEntryTemp.ParentLogEntry) != null)
					{
						logEntryTemp.ExceptionThrown = true;
					}
				}

				// plugin context
				if (context != null)
				{
					logEntry.Information = PluginInfo.GetPluginExecutionInfo(OrganizationService, context);
				}

				// increment the log entries index
				logEntry.CurrentEntryIndex = CurrentEntryIndex++;

				// code info
				logEntry.StackTrace = stackTrace ?? logEntry.StackTrace ?? Helpers.GetStackTrace(-1, "CrmLog");
				logEntry.CallingClass = callingClass ?? logEntry.CallingClass ?? Helpers.GetClassName(-1, "CrmLog");
				logEntry.CallingFunction = callingFunction ?? logEntry.CallingFunction;
				logEntry.CallingLineNumber = callingLineNumber;

				logQueue.Enqueue(logEntry);
				OnLogEntryAdded(new LogEntryAddedEventArgs { LogEntry = logEntry });

				// keep the first entry with an exception to show in root
				exceptionLogEntry = logEntry.ExceptionThrown ? logEntry : exceptionLogEntry;

				if (IsAutoLogToConsole)
				{
					LogToConsole(logEntry);
				}
			}
			catch
			{
				// ignored
			}
		}

		private void OnLogEntryAdded(LogEntryAddedEventArgs e)
		{
			LogEntryAdded?.Invoke(this, e);
		}

		public void LogKeyValues(string title, string[] paramNames, object[] paramValues,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				paramNames.Require(nameof(paramNames));
				paramValues.Require(nameof(paramValues));

				var paramInfoBuilder = new StringBuilder();

				for (var i = 0; i < paramNames.Length; i++)
				{
					if (i != 0)
					{
						paramInfoBuilder.Append("\r\n");
					}

					paramInfoBuilder
						.Append(paramNames[i])
						.Append(" = ")
						.Append(Helpers.GetStringRepresentation(paramValues[i]));
				}

				Log(new LogEntry(title, level, null, null, paramInfoBuilder.ToString()),
					regardingType, regardingName, context,
					Helpers.GetClassName(-1, "CrmLog"), Helpers.GetStackTrace(-1, "CrmLog"),
					null, false, callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		public void LogKeyValues(string title, IDictionary<string, object> parameters,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				parameters.Require(nameof(parameters));
				LogKeyValues(title, parameters.Keys.ToArray(), parameters.Values.ToArray(),
					level, regardingType, regardingName, context, callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Logs the current execution line in the code.
		/// </summary>
		/// <param name="message">[OPTIONAL] The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogLine(string message = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Execution reached line " + callingLineNumber;

				var logEntry = new LogEntry(message ?? defaultMessage);
				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "CrmLog"), -1,
					false, callingFunction, callingLineNumber);
			}
			catch
			{
				// ignored
			}
		}

		/// <summary>
		///     Formats the message with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="message">The message to output to console.</param>
		/// <param name="logLevel">Log level to use for formatting. Default is 'Info'.</param>
		public void LogToConsole(string message, LogLevel logLevel = LogLevel.Info)
		{
			LogToConsole(new LogEntry(message, logLevel));
		}

		/// <summary>
		///     Formats the log entry with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information.</param>
		public void LogToConsole(LogEntry logEntry)
		{
			try
			{
				logEntry.Require(nameof(logEntry));

				if (!IsConsoleEnabled || logEntry.Level > MaxConsoleLogLevel)
				{
					return;
				}

				if (logEntry.ExceptionThrown)
				{
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================ !! EXCEPTION !! ===============================");
					Console.ResetColor();
					Console.WriteLine(GetFormattedEntry(logEntry));
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================================================================");
					Console.ResetColor();
				}
				else
				{
					Console.ForegroundColor = ConsoleColor.DarkGreen;
					Console.Write("{0:ddd hh:mm:ss tt: }", DateTime.Now);

					switch (logEntry.Level)
					{
						case LogLevel.Error:
							Console.BackgroundColor = ConsoleColor.White;
							Console.ForegroundColor = ConsoleColor.Red;
							break;
						case LogLevel.Warning:
							Console.ForegroundColor = ConsoleColor.Yellow;
							break;
						case LogLevel.Debug:
							Console.ForegroundColor = ConsoleColor.DarkCyan;
							break;
						default:
							Console.ResetColor();
							break;
					}

					Console.WriteLine(logEntry.Message);
					Console.ResetColor();
				}
			}
			catch (Exception)
			{
				// ignored
			}
		}

		/// <summary>
		///     Sets the state at which the execution ended
		/// </summary>
		/// <param name="state">The state at which the execution ended</param>
		public void SetExecutionState(ExecutionEndState state)
		{
			AssemblyExecutionState = state;
		}

		/// <summary>
		///     Sets the state at which the execution ended as a failure
		/// </summary>
		public void ExecutionFailed()
		{
			AssemblyExecutionState = ExecutionEndState.Failure;
		}

		/// <summary>
		///     Created the parent log, and creates each log entry in the queue.
		/// </summary>
		/// <param name="inBulk">If true, created all log entries using ExecuteMultiple</param>
		public void Flush(bool inBulk = true)
		{
			var lockObject = this;

			Action action =
				() =>
				{
					lock (lockObject)
					{
						if (MaxLogLevel == LogLevel.None
							|| logQueue.All(entry => entry.Level == LogLevel.None)
							|| (logQueue.All(entry => entry.Level == LogLevel.None || entry.Level > MaxLogLevel)
								&& AssemblyExecutionState != ExecutionEndState.Failure))
						{
							return;
						}

						RunFlushAction(inBulk);
					}
				};

			if (isPlugin || IsOfflineEnabled)
			{
				action.Invoke();
			}
			else
			{
				new Thread(() => action()).Start();
			}
		}

		#endregion

		private static string EscapeCsv(string input)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return input;
			}

			return "\"" + input.Replace("\"", "\"\"") + "\"";
		}

		private static string BuildLogId(LogEntry logEntry)
		{
			return $"LogEntry-{logEntry.StartDate?.ToLocalTime() ?? DateTime.Now:yyyy_MM_dd-HH_mm_ss_fff}";
		}

		#region Flush

		private void RunFlushAction(bool inBulk)
		{
			try
			{
				parentLog["ldv_executionendstate"] = new OptionSetValue((int)AssemblyExecutionState);
				parentLog["ldv_executionduration"] = (int)executionTimer.ElapsedMilliseconds;
				parentLog["ldv_exceptionthrown"] = exceptionThrown;

				if (IsOfflineEnabled)
				{
					offlineQueue = new Queue<LogEntry>(logQueue);
				}

				if (IsOfflineOnly || isBulkPreviously == true)
				{
					logQueue.Clear();
					return;
				}

				var requests = new List<OrganizationRequest>();
				var serialisedLogEntries = new StringBuilder();

				inBulk = isBulkPreviously == null && inBulk;

				if (!inBulk && !isParentCreated)
				{
					OrganizationService.Create(parentLog);
				}

				while (logQueue.Count > 0)
				{
					var logEntry = logQueue.Dequeue();

					// if the log entry's level is above the maximum, then no need to log it
					// unless the execution failed
					if (logEntry.Level > MaxLogLevel
						&& AssemblyExecutionState != ExecutionEndState.Failure)
					{
						continue;
					}

					var target = CreateEntryEntity(logEntry);

					if (inBulk)
					{
						serialisedLogEntries.Append("<|||>")
							.Append(EntitySerializer.SerializeObject(target));
					}
					else
					{
						OrganizationService.Create(target);
					}
				}

				if (exceptionLogEntry != null)
				{
					var updatedParent =
						new Entity("ldv_log")
						{
							Id = parentLog.Id,
							["ldv_exceptionlogentry"] =
								new EntityReference("ldv_logentry", exceptionLogEntry.LogEntryId),
							["ldv_exceptionmessage"] = exceptionLogEntry.Message
						};

					if (inBulk)
					{
						serialisedLogEntries.Append("<|||><PARENT>")
							.Append(EntitySerializer.SerializeObject(updatedParent));
					}
					else
					{
						OrganizationService.Update(updatedParent);
					}
				}

				if (inBulk)
				{
					parentLog["ldv_serialisedlogentries"] = serialisedLogEntries.ToString().Compress();
					requests.Add(new CreateRequest { Target = parentLog });
					CrmHelpers.ExecuteBulk(OrganizationService, requests);
				}

				isParentCreated = true;
				isBulkPreviously = inBulk;
			}
			catch (Exception ex)
			{
				try
				{
					if (IsFailOver)
					{
						FlushOffline();
					}
				}
				catch
				{
				}

				throw new FlushException(ex.Message, ex);
			}
			finally
			{
				if (!IsFailOver)
				{
					FlushOffline();
				}
			}
		}

		/// <summary>
		///     Flushes to local file.
		/// </summary>
		private void FlushOffline()
		{
			try
			{
				if (!IsOfflineEnabled)
				{
					return;
				}

				PrepareLogPath();

				if (IsCreateFile())
				{
					CreateLogFile();
				}

				// open the log file and write the log entries
				using (var file = File.Open(OfflinePath, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
				{
					using (var stream = new StreamWriter(file))
					{
						while (offlineQueue.Any())
						{
							stream.Write(GetFormattedCsvEntry(offlineQueue.Dequeue()));
						}

						stream.Flush();
					}
				}
			}
			catch
			{
				// ignored
			}
		}

		private bool IsCreateFile()
		{
			// if the file or config do not exist, create file
			if (!File.Exists(OfflinePath) || Config == null)
			{
				return true;
			}

			// check size and date limit for split
			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			var dateText = File.Exists(dateFile)
				? File.ReadAllText(dateFile)
				: DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff");

			if (!File.Exists(dateFile))
			{
				File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
			}

			var fileDate = DateTime.ParseExact(dateText, "yyyy-MM-dd_HH-mm-ss-fff", CultureInfo.InvariantCulture,
				DateTimeStyles.AssumeUniversal);

			var newFileDate = string.Format("{0:" + (Config.FileDateFormat ?? "yyyy-MM-dd_HH-mm-ss-fff") + "}",
				fileDate.ToLocalTime());
			var datedName = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				$"{Path.GetFileNameWithoutExtension(OfflinePath)}_{newFileDate}{Path.GetExtension(OfflinePath)}");

			// option exists for size limit
			if ((Config.FileSplitMode == SplitMode.Size || Config.FileSplitMode == SplitMode.Both)
				&& Config.MaxFileSize > 0 && new FileInfo(OfflinePath).Length / 1024 > Config.MaxFileSize)
			{
				File.Move(OfflinePath, datedName);
				return true;
			}

			// option exists for date limit
			if ((Config.FileSplitMode == SplitMode.Date || Config.FileSplitMode == SplitMode.Both)
				&& Config.FileSplitFrequency != null)
			{
				var splitDate = Config.FileSplitDate;

				// calculate the target split date for the file based on its creation date
				switch (Config.FileSplitFrequency)
				{
					case SplitFrequency.Hourly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							fileDate.Hour, splitDate.Minute, splitDate.Second).AddHours(1);
						break;

					case SplitFrequency.Daily:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddDays(1);
						break;

					case SplitFrequency.Monthly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddMonths(1);
						break;

					case SplitFrequency.Yearly:
						splitDate = new DateTime(fileDate.Year, splitDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddYears(1);
						break;
				}

				// rename
				if (DateTime.UtcNow > splitDate)
				{
					File.Move(OfflinePath, datedName);
					return true;
				}
			}

			return false;
		}

		private void PrepareLogPath()
		{
			// no file name specified, create default name
			if (string.IsNullOrWhiteSpace(OfflinePath))
			{
				OfflinePath = $"C:\\Logs\\{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}.csv";
			}

			// if directory was given, add filename to it
			if (!Path.HasExtension(OfflinePath))
			{
				OfflinePath = Path.Combine(OfflinePath, Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common") + ".csv");
			}

			var folder = Path.GetDirectoryName(OfflinePath);

			// if categorisation is needed, add the assembly folder
			if (Config != null && Config.CategoriseByType == true)
			{
				OfflinePath = Path.Combine(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), Path.GetFileName(OfflinePath));

				if (!string.IsNullOrWhiteSpace(folder))
				{
					OfflinePath = Path.Combine(folder, OfflinePath);
				}
			}

			folder = Path.GetDirectoryName(OfflinePath);

			// create path if it doesn't exist
			if (!string.IsNullOrWhiteSpace(folder))
			{
				Directory.CreateDirectory(folder);
			}
		}

		/// <summary>
		///     Creates an entity containing the log entry data
		/// </summary>
		/// <param name="logEntry">The log entry.</param>
		/// <returns>The CRM entity object including all info in the log entry object</returns>
		private Entity CreateEntryEntity(LogEntry logEntry)
		{
			var target =
				new Entity("ldv_logentry")
				{
					Id = logEntry.LogEntryId,
					["ldv_name"] = BuildLogId(logEntry),
					["ldv_message"] = logEntry.Message,
					["ldv_entryindex"] = logEntry.CurrentEntryIndex,
					["ldv_startdate"] = logEntry.StartDate,
					["ldv_regardingtype"] = logEntry.RegardingType,
					["ldv_regardingname"] = logEntry.RegardingName,
					["ldv_stacktrace"] = logEntry.StackTrace
				};

			if (logEntry.Exception != null)
			{
				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					target["ldv_message"] = logEntry.Message = "Exception: " + logEntry.Exception.Message;
				}

				target["ldv_exception"] = logEntry.Exception.GetType().Name;
				target["ldv_exceptionsource"] = logEntry.Exception.Source;
				target["ldv_stacktrace"] = logEntry.Exception.StackTrace;

				if (logEntry.Exception.InnerException != null)
				{
					target["ldv_innerexception"] = logEntry.Exception.InnerException.GetType().Name;
					target["ldv_innerexceptionmessage"] = logEntry.Exception.InnerException.Message;
					target["ldv_innerexceptionsource"] = logEntry.Exception.InnerException.Source;
					target["ldv_innerexceptionstacktrace"] = logEntry.Exception.InnerException.StackTrace;
				}
			}

			target["ldv_exceptionthrown"] = logEntry.ExceptionThrown;

			target["ldv_level"] = new OptionSetValue((int)logEntry.Level);

			if (logEntry.UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", logEntry.UserId);
			}
			else if (UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", UserId);
			}

			target["ldv_assembly"] = logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common");
			target["ldv_class"] = logEntry.CallingClass;
			target["ldv_callingfunction"] = logEntry.CallingFunction;
			target["ldv_linenumber"] = logEntry.CallingLineNumber;

			if (logEntry.ElapsedTime > -1)
			{
				target["ldv_executionduration"] = logEntry.ElapsedTime;
			}

			target["ldv_information"] = logEntry.Information;

			target["ldv_parentlogid"] = parentLog.ToEntityReference();

			if (logEntry.ParentLogEntry != null)
			{
				target["ldv_parentlogentryid"] = new EntityReference("ldv_logentry", logEntry.ParentLogEntry.LogEntryId);
			}

			return target;
		}

		private void CreateLogFile()
		{
			File.Create(OfflinePath).Close();

			var data = Encoding.UTF8.GetBytes("Log ID,Assembly,Entry Class,Entry Function,Date,Index," +
				"Log Level,Duration (ms),Class,Function,Line Number,Message,Exception Thrown," +
				"Exception,Source,Stack Trace,Inner Exception,Inner Source,Information," +
				"Log Start Date,Execution State,Execution Duration," +
				"Regarding Type,Regarding Name,Regarding ID,User ID\r\n");
			var bytes = Encoding.UTF8.GetPreamble().Concat(data).ToArray();
			File.WriteAllBytes(OfflinePath, bytes);

			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
		}

		private string GetFormattedEntry(LogEntry logEntry)
		{
			var stringBuilder = new StringBuilder();

			stringBuilder.AppendFormat("Start date: {0}\r\n", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
			stringBuilder.AppendFormat("Log level: {0}\r\n", logEntry.Level);
			stringBuilder.AppendFormat("Duration: {0} ms\r\n", logEntry.ElapsedTime);
			stringBuilder.AppendFormat("Assembly: {0}\r\n",
				logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"));
			stringBuilder.AppendFormat("Class: {0}\r\n", logEntry.CallingClass);
			stringBuilder.AppendFormat("Calling function: {0}\r\n", logEntry.CallingFunction);
			stringBuilder.AppendFormat("Line number: {0}\r\n", logEntry.CallingLineNumber);

			if (logEntry.Exception != null)
			{
				stringBuilder.AppendFormat("Message: {0}\r\n",
					string.IsNullOrWhiteSpace(logEntry.Message) ? logEntry.Exception.Message : logEntry.Message);

				stringBuilder.AppendFormat("Exception: {0}\r\n" + "Source: {1}\r\n" + "Stack trace: {2}\r\n",
					logEntry.Exception.GetType().Name, logEntry.Exception.Source, logEntry.Exception.StackTrace);

				if (logEntry.Exception.InnerException != null)
				{
					stringBuilder.AppendFormat("Inner exception: {0}\r\n" + "Source: {1}\r\n",
						logEntry.Exception.InnerException.GetType().Name, logEntry.Exception.InnerException.Message);
				}
			}
			else
			{
				stringBuilder.AppendFormat("Message: {0}\r\n", logEntry.Message);
				stringBuilder.AppendFormat("Stack trace: {0}\r\n", logEntry.StackTrace);
			}

			stringBuilder.AppendFormat("Information: {0}", logEntry.Information);

			return stringBuilder.ToString();
		}

		private string GetFormattedCsvEntry(LogEntry logEntry)
		{
			var stringBuilder = new StringBuilder();

			stringBuilder.AppendFormat("{0}", parentLog.GetAttributeValue<string>("ldv_name"));
			stringBuilder.AppendFormat(",{0}",
				EscapeCsv(logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryclass")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryfunction")));
			stringBuilder.AppendFormat(",{0}", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
			stringBuilder.AppendFormat(",{0}", logEntry.CurrentEntryIndex);
			stringBuilder.AppendFormat(",{0}", logEntry.Level);
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.ElapsedTime.ToString()));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingClass));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingFunction));
			stringBuilder.AppendFormat(",{0}", logEntry.CallingLineNumber);

			if (logEntry.Exception != null)
			{
				stringBuilder.AppendFormat(",{0}",
					string.IsNullOrWhiteSpace(logEntry.Message)
						? EscapeCsv(logEntry.Exception.Message)
						: EscapeCsv(logEntry.Message));

				stringBuilder.AppendFormat(",{0}", logEntry.ExceptionThrown);
				stringBuilder.AppendFormat(",{0},{1},{2}",
					EscapeCsv(logEntry.Exception.GetType().Name),
					EscapeCsv(logEntry.Exception.Source), EscapeCsv(logEntry.Exception.StackTrace));

				if (logEntry.Exception.InnerException != null)
				{
					stringBuilder.AppendFormat(",{0},{1}",
						EscapeCsv(logEntry.Exception.InnerException.GetType().Name),
						EscapeCsv(logEntry.Exception.InnerException.Message));
				}
				else
				{
					stringBuilder.Append(",,");
				}
			}
			else
			{
				stringBuilder.AppendFormat(",{0},{1},,,,,", EscapeCsv(logEntry.Message), logEntry.ExceptionThrown);
			}

			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.Information));

			stringBuilder.AppendFormat(",{0}", LogStartDate);
			stringBuilder.AppendFormat(",{0}", AssemblyExecutionState);
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<int>("ldv_executionduration"));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingType));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingName));
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<string>("ldv_regardingid"));
			stringBuilder.AppendFormat(",{0}\r\n", logEntry.UserId == Guid.Empty ? UserId : logEntry.UserId);

			return stringBuilder.ToString();
		}

		#endregion

		#region Init

		private PrivateConfiguration GetConfiguration()
		{
			try
			{
				if (OrganizationService != null)
				{
					var config = CrmHelpers.GetGenericConfig(OrganizationService, orgId);

					if (config != null)
					{
						return
							new PrivateConfiguration
							{
								LogLevel = (LogLevel)(config.GetAttributeValue<OptionSetValue>("ldv_loglevel")
									?? new OptionSetValue((int)LogLevel.Warning)).Value,
								LogMode = (LogMode)(config.GetAttributeValue<OptionSetValue>("ldv_logmode")
									?? new OptionSetValue((int)LogMode.Crm)).Value,
								LogPath = config.GetAttributeValue<string>("ldv_logpath"),
								MaxFileSize = config.GetAttributeValue<int?>("ldv_maxfilesize"),
								FileDateFormat = config.GetAttributeValue<string>("ldv_logfiledateformat"),
								FileSplitMode = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode") == null
									? null
									: (SplitMode?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode").Value,
								FileSplitFrequency = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency") == null
									? null
									: (SplitFrequency?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency").Value,
								FileSplitDate = config.GetAttributeValue<DateTime>("ldv_logfilesplitdate"),
								CategoriseByType = config.GetAttributeValue<bool?>("ldv_iscategorisebytype"),
								AssemblyFilter = config.GetAttributeValue<string>("ldv_assemblyfilter"),
								AssemblyExclusion = config.GetAttributeValue<string>("ldv_assemblyexclusion")
							};
					}
				}
			}
			catch
			{
				// ignored
			}

			return null;
		}

		/// <summary>
		///     Initialises the CRM logger.
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum logging level to use, above which, no logs will be saved</param>
		private void InitialiseLog(IOrganizationService organizationService,
			LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			logQueue = new Queue<LogEntry>();
			offlineQueue = new Queue<LogEntry>();
			execSeqStack = new Stack<LogEntry>();

			functionTimersStack = new Stack<Stopwatch>();
			durationsStack = new Stack<int>();

			OrganizationService = organizationService;

			LogStartDate = DateTime.UtcNow;
			CurrentEntryIndex = 1;

			var config = GetConfiguration();
			MaxLogLevel = maximumLevel ?? config?.LogLevel ?? LogLevel.Warning;

			// if assembly is excluded, then turn off logging
			if (!string.IsNullOrWhiteSpace(config?.AssemblyFilter))
			{
				var isAssemblyIncluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyFilter);
				MaxLogLevel = isAssemblyIncluded ? MaxLogLevel : LogLevel.None;
			}

			if (!string.IsNullOrWhiteSpace(config?.AssemblyExclusion))
			{
				var isAssemblyExcluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyExclusion);
				MaxLogLevel = isAssemblyExcluded ? LogLevel.None : MaxLogLevel;
			}

			IsOfflineEnabled = !isSandboxMode && (IsOfflineEnabled
				|| (config != null && config.LogMode == LogMode.File)
				|| (config != null && config.LogMode == LogMode.Both));

			if (IsOfflineEnabled)
			{
				IsOfflineOnly = IsOfflineOnly || (config != null && config.LogMode == LogMode.File);
				InitOfflineLog(config == null ? string.Empty : config.LogPath, false, config);
			}

			try
			{
				if (UserId == Guid.Empty && !IsOfflineOnly && MaxLogLevel != LogLevel.None)
				{
					UserId = ((WhoAmIResponse)OrganizationService.Execute(new WhoAmIRequest())).UserId;
				}
			}
			catch
			{
				// ignored
			}

			InitLogEntity(callingFunction);
		}

		/// <summary>
		///     Initializes the parent log entity.
		/// </summary>
		private void InitLogEntity([CallerMemberName] string callingFunction = "")
		{
			parentLog =
				new Entity("ldv_log")
				{
					Id = Guid.NewGuid(),
					["ldv_name"] = $"Log-{LogStartDate.ToLocalTime():yyyy_MM_dd-HH_mm_ss_fff}",
					["ldv_assembly"] = Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"),
					["ldv_entryclass"] = Helpers.GetClassName(-1, "CrmLog"),
					["ldv_entryfunction"] = callingFunction,
					["ldv_startdate"] = LogStartDate,
					["ldv_user"] = new EntityReference("systemuser", UserId),
					["ldv_executionendstate"] = new OptionSetValue((int)ExecutionEndState.Success)
				};
		}

		#endregion

		#region Inner classes

		private class FlushException : Exception
		{
			public FlushException()
			{
			}

			public FlushException(string message) : base(message)
			{
			}

			public FlushException(string message, Exception innerException) : base(message, innerException)
			{
			}

			protected FlushException(SerializationInfo info, StreamingContext context) : base(info, context)
			{
			}
		}

		private class PrivateConfiguration : FileConfiguration
		{
			internal LogLevel LogLevel
			{
				get; set;
			}

			internal LogMode LogMode
			{
				get; set;
			}

			internal string LogPath
			{
				get; set;
			}

			internal string AssemblyFilter
			{
				get; set;
			}

			internal string AssemblyExclusion
			{
				get; set;
			}
		}

		#endregion
	}

	public class LogEntryAddedEventArgs : EventArgs
	{
		public LogEntry LogEntry
		{
			get; set;
		}
	}

	public class FileConfiguration
	{
		public int? MaxFileSize
		{
			get; set;
		}

		public string FileDateFormat
		{
			get; set;
		}

		public SplitMode? FileSplitMode
		{
			get; set;
		}

		public SplitFrequency? FileSplitFrequency
		{
			get; set;
		}

		public DateTime FileSplitDate
		{
			get; set;
		}

		public bool? CategoriseByType
		{
			get; set;
		}
	}

	/// <summary>
	///     Contains information related to the log entry.<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class LogEntry
	{
		private int elapsedTime;
		private int currentEntryIndex;

		#region Constructors

		public LogEntry(string message, LogLevel level = LogLevel.Info, string regardingType = "", string regardingName = "",
			string information = "") : this(message, null, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(Exception exception, string message = "", string regardingType = "", string regardingName = "",
			string information = "", LogLevel level = LogLevel.Error)
			: this(message, exception, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string information)
			: this(message, exception, level, string.Empty, string.Empty, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information)
		{
			Message = message;
			Level = level;
			Exception = exception;
			RegardingType = regardingType;
			RegardingName = regardingName;
			Information = information;
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information, Guid userId) : this(message, exception, level, regardingType, regardingName, information)
		{
			UserId = userId;
		}

		#endregion

		#region Instance variables

		public Guid LogEntryId { get; } = Guid.NewGuid();

		public LogEntry ParentLogEntry
		{
			get; set;
		}

		public string Message
		{
			get; set;
		}

		public DateTime? StartDate
		{
			get; set;
		}

		public LogLevel Level
		{
			get; set;
		}

		public Guid UserId
		{
			get; set;
		}

		public string RegardingType
		{
			get; set;
		}

		public string RegardingName
		{
			get; set;
		}

		public Exception Exception
		{
			get; set;
		}

		public bool ExceptionThrown
		{
			get; set;
		}

		public string Assembly
		{
			get; set;
		}

		public string StackTrace
		{
			get; set;
		}

		public string CallingClass
		{
			get; set;
		}

		public string CallingFunction
		{
			get; set;
		}

		public int CallingLineNumber
		{
			get; set;
		}

		public string Information
		{
			get; set;
		}

		public int CurrentEntryIndex
		{
			get
			{
				return currentEntryIndex;
			}
			set
			{
				currentEntryIndex = value <= 0 ? 1 : value;
			}
		}

		public int ElapsedTime
		{
			get
			{
				return elapsedTime;
			}
			set
			{
				elapsedTime = elapsedTime < -1 ? -1 : value;
			}
		}

		#endregion
	}

	#endregion

	#region Plugin classes

	public enum PluginStage
	{
		All,
		PreValidation = 10,
		PreOperation = 20,
		PostOperation = 40
	}

	public enum PluginMode
	{
		Synchronous = 0,
		Asynchronous = 1,
		Both = 2
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public abstract class PluginLogic<TPlugin>
		where TPlugin : IPlugin
	{
		protected readonly string intendedPluginMessage;
		protected readonly PluginStage intendedPluginStage;
		protected readonly string intendedEntity;

		protected TPlugin plugin;

		protected IServiceProvider serviceProvider;
		protected IPluginExecutionContext context;
		protected IOrganizationServiceFactory serviceFactory;
		protected ITracingService tracingService;
		protected IOrganizationService service;

		protected CrmLog log;

		protected PluginLogic(string intendedPluginMessage, PluginStage intendedPluginStage, string intendedEntity = null)
		{
			this.intendedPluginMessage = intendedPluginMessage;
			this.intendedPluginStage = intendedPluginStage;
			this.intendedEntity = intendedEntity;
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider)
		{
			Execute(plugin, serviceProvider, PluginUser.System);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, bool isLogEnabled)
		{
			Execute(plugin, serviceProvider, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, Guid? userId,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, user, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user, Guid? userId,
			bool isLogEnabled = true)
		{
			this.plugin = plugin;
			this.serviceProvider = serviceProvider;

			InitialisePlugin(user, userId);

			try
			{
				tracingService.Trace("Initialising log ...");
				log = new CrmLog(serviceProvider);
				tracingService.Trace("Finished initialising log.");

				if (isLogEnabled)
				{
					tracingService.Trace("Log enabled.");

					tracingService.Trace("Setting entry class in log ...");
					log.SetEntryClass(typeof(TPlugin).FullName);

					tracingService.Trace("Checking regarding to be set in log ...");
					if (context.PrimaryEntityName != null && context.PrimaryEntityName != "none"
						&& context.PrimaryEntityId != Guid.Empty)
					{
						tracingService.Trace("Setting regarding in log ...");
						log.SetRegarding(context.PrimaryEntityName, context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					tracingService.Trace("Logging execution start ...");
					log.LogExecutionStart();
				}

				tracingService.Trace("Executing plugin logic ...");
				ExecuteLogic();
				tracingService.Trace("Finished executing plugin logic.");
			}
			catch (Exception ex)
			{
				tracingService.Trace("Exception occurred.");

				if (isLogEnabled)
				{
					log.ExecutionFailed();
					tracingService.Trace("Logging exception ...");
					log.Log(ex, context);
				}

				tracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					tracingService.Trace("Logging execution end ...");
					log.LogExecutionEnd();
				}

				tracingService.Trace("Finished executing plugin.");
			}
		}

		protected abstract void ExecuteLogic();

		protected Entity GetPreImage()
		{
			var image = context.PreEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
			}

			return image;
		}

		protected Entity GetPostImage()
		{
			var image = context.PostEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a post-image for this step.");
			}

			return image;
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected virtual void ValidateRegistration()
		{
			if (!string.IsNullOrWhiteSpace(intendedEntity) && context.PrimaryEntityName != intendedEntity)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong entity: {context.PrimaryEntityName}, "
						+ $"expected: {intendedEntity}");
			}

			if (!string.IsNullOrWhiteSpace(intendedPluginMessage) && context.MessageName != intendedPluginMessage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong message: {context.MessageName}, "
						+ $"expected: {intendedPluginMessage}.");
			}

			if (intendedPluginStage != PluginStage.All && context.Stage != (int)intendedPluginStage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong stage: {context.Stage}, "
						+ $"expected: {intendedPluginStage}");
			}
		}

		protected void InitialisePlugin(PluginUser user = PluginUser.System, Guid? userId = null)
		{
			tracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

			tracingService.Trace("Getting context ...");
			context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			ValidateRegistration();

			tracingService.Trace("Getting factory ...");
			serviceFactory = (IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory));

			switch (user)
			{
				case PluginUser.ContextUser:
					tracingService.Trace("Running as ContextUser.");
					userId = context.UserId;
					break;

				case PluginUser.InitiatingUser:
					tracingService.Trace("Running as InitiatingUserId.");
					userId = context.InitiatingUserId;
					break;

				case PluginUser.System:
					tracingService.Trace("Running as System.");
					userId = null;
					break;

				case PluginUser.Custom:
					tracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Plugin user type is out of range.");
			}

			tracingService.Trace("Getting service ...");
			service = serviceFactory.CreateOrganizationService(userId);

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise plugin due to invalid context.");
			}

			tracingService.Trace($"Initialised plugin.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public abstract class StepLogic<TCodeActivity>
		where TCodeActivity : CodeActivity
	{
		protected TCodeActivity codeActivity;

		protected CodeActivityContext executionContext;
		protected IWorkflowContext context;
		protected IOrganizationServiceFactory serviceFactory;
		protected ITracingService tracingService;
		protected IOrganizationService service;

		protected CrmLog log;

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext)
		{
			Execute(codeActivity, executionContext, PluginUser.System);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			bool isLogEnabled)
		{
			Execute(codeActivity, executionContext, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			Guid? userId, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, user, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, Guid? userId, bool isLogEnabled = true)
		{
			this.codeActivity = codeActivity;
			this.executionContext = executionContext;

			InitialiseCodeActivity(user, userId);

			try
			{
				tracingService.Trace("Initialising log ...");
				log = new CrmLog(executionContext);
				tracingService.Trace("Finished initialising log.");

				if (isLogEnabled)
				{
					tracingService.Trace("Log enabled.");

					tracingService.Trace("Setting entry class in log ...");
					log.SetEntryClass(typeof(TCodeActivity).FullName);

					tracingService.Trace("Checking regarding to be set in log ...");
					if (context.PrimaryEntityName != null && context.PrimaryEntityName != "none"
						&& context.PrimaryEntityId != Guid.Empty)
					{
						tracingService.Trace("Setting regarding in log ...");
						log.SetRegarding(context.PrimaryEntityName, context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					tracingService.Trace("Logging execution start ...");
					log.LogExecutionStart();
				}

				tracingService.Trace("Executing step logic ...");
				ExecuteLogic();
				tracingService.Trace("Finished executing step.");
			}
			catch (Exception ex)
			{
				if (isLogEnabled)
				{
					tracingService.Trace("Exception occurred.");
					log.ExecutionFailed();
					tracingService.Trace("Logging exception ...");
					tracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
					log.Log(ex, context);
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					tracingService.Trace("Logging execution end ...");
					log.LogExecutionEnd();
				}

				tracingService.Trace("Finished executing step.");
			}
		}

		protected abstract void ExecuteLogic();

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected void InitialiseCodeActivity(PluginUser user = PluginUser.System, Guid? userId = null)
		{
			tracingService = executionContext.GetExtension<ITracingService>();
			context = executionContext.GetExtension<IWorkflowContext>();
			tracingService.Trace("Got context.");
			serviceFactory = executionContext.GetExtension<IOrganizationServiceFactory>();
			tracingService.Trace("Got factory.");

			switch (user)
			{
				case PluginUser.ContextUser:
					userId = context.UserId;
					tracingService.Trace("Running as ContextUser.");
					break;

				case PluginUser.InitiatingUser:
					userId = context.InitiatingUserId;
					tracingService.Trace("Running as InitiatingUserId.");
					break;

				case PluginUser.System:
					userId = null;
					tracingService.Trace("Running as System.");
					break;

				case PluginUser.Custom:
					tracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Step user type is out of range.");
			}

			service = serviceFactory.CreateOrganizationService(userId);
			tracingService.Trace("Got service.");

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise workflow step due to invalid context.");
			}

			tracingService.Trace($"Initialised step.");
		}
	}

	#endregion
}
